# 动态配置重载设计方案

## 1. 背景与目标

### 1.1 当前状态

`ICfgRoot.ToMicrosoftConfiguration()` 返回的 `IConfigurationRoot` 是一个静态快照。当底层配置源发生变化时，已返回的 `IConfigurationRoot` 实例不会自动更新。

### 1.2 设计目标

1. **动态更新**：当任意配置源变化时，`ToMicrosoftConfiguration()` 返回的配置能自动反映最新值
2. **性能优化**：避免任意源变化都触发整体重载，采用增量更新策略
3. **层级覆盖感知**：只有当最终合并值真正发生变化时才触发通知
4. **多源支持**：支持多个配置源同时存在的场景

## 2. 核心设计

### 2.1 架构概览

```
┌─────────────────────────────────────────────────────────────────┐
│                        MergedCfgRoot                            │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ Source L1   │  │ Source L2   │  │ Source L3   │  ...        │
│  │ (低优先级)   │  │ (中优先级)   │  │ (高优先级)   │             │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │
│         │                │                │                     │
│         ▼                ▼                ▼                     │
│  ┌─────────────────────────────────────────────────────────────┤
│  │              ChangeCoordinator (变更协调器)                  │
│  │  - 收集各源的变更事件                                        │
│  │  - 防抖处理 (Debounce)                                       │
│  │  - 增量合并计算                                              │
│  │  - 最终值变化检测                                            │
│  └──────────────────────────┬──────────────────────────────────┤
│                             │                                   │
│                             ▼                                   │
│  ┌─────────────────────────────────────────────────────────────┤
│  │              MergedConfigurationRoot                         │
│  │  - 缓存最终合并值                                            │
│  │  - 提供 IChangeToken                                         │
│  │  - 仅在最终值变化时触发 Reload                               │
│  └─────────────────────────────────────────────────────────────┤
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件

#### 2.2.1 ChangeCoordinator (变更协调器)

负责协调多个配置源的变更事件，实现智能合并和防抖。

```csharp
internal sealed class ChangeCoordinator : IDisposable
{
    private readonly ConcurrentDictionary<string, string?> _mergedSnapshot;
    private readonly List<(int Level, IConfigurationProvider Provider)> _providers;
    private readonly List<IDisposable> _changeTokenRegistrations;
    private readonly Timer _debounceTimer;
    private readonly object _lock = new();
    private readonly HashSet<int> _pendingChangeLevels;

    // 防抖时间窗口（毫秒）
    private const int DebounceMs = 100;

    public event Action<IReadOnlyDictionary<string, ConfigChange>>? OnMergedChanges;
}
```

#### 2.2.2 ConfigChange (配置变更记录)

```csharp
public readonly struct ConfigChange
{
    public string Key { get; init; }
    public string? OldValue { get; init; }
    public string? NewValue { get; init; }
    public ChangeType Type { get; init; }
}

public enum ChangeType
{
    Added,
    Modified,
    Removed
}
```

#### 2.2.3 MergedConfigurationProvider

自定义的 `IConfigurationProvider` 实现，支持增量更新。

```csharp
internal sealed class MergedConfigurationProvider : ConfigurationProvider, IDisposable
{
    private readonly ChangeCoordinator _coordinator;
    private CancellationTokenSource _reloadTokenSource;

    public override IChangeToken GetReloadToken()
    {
        return new CancellationChangeToken(_reloadTokenSource.Token);
    }

    internal void ApplyChanges(IReadOnlyDictionary<string, ConfigChange> changes)
    {
        foreach (var (key, change) in changes)
        {
            if (change.Type == ChangeType.Removed)
                Data.Remove(key);
            else
                Data[key] = change.NewValue;
        }

        // 触发 reload token
        var oldSource = Interlocked.Exchange(
            ref _reloadTokenSource,
            new CancellationTokenSource());
        oldSource.Cancel();
        oldSource.Dispose();
    }
}
```

## 3. 变更检测流程

### 3.1 流程图

```
源变化事件
    │
    ▼
┌───────────────────┐
│ 记录变化的层级     │
│ _pendingChangeLevels.Add(level)
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ 重置防抖计时器     │
│ _debounceTimer.Change(DebounceMs)
└─────────┬─────────┘
          │
          │ (等待防抖窗口)
          ▼
┌───────────────────┐
│ 防抖窗口结束       │
│ ProcessPendingChanges()
└─────────┬─────────┘
          │
          ▼
┌───────────────────────────────────┐
│ 仅重新加载变化的层级              │
│ foreach (level in pendingLevels)  │
│   providers[level].Load()         │
└─────────┬─────────────────────────┘
          │
          ▼
┌───────────────────────────────────┐
│ 增量合并计算                      │
│ ComputeMergedChanges()            │
└─────────┬─────────────────────────┘
          │
          ▼
┌───────────────────────────────────┐
│ 比较最终合并值                    │
│ 只保留真正变化的键                │
└─────────┬─────────────────────────┘
          │
          ▼
┌───────────────────────────────────┐
│ 有变化？                          │
│ actualChanges.Count > 0           │
└─────────┬─────────────────────────┘
          │
    ┌─────┴─────┐
    │ Yes       │ No
    ▼           ▼
触发通知      静默忽略
```

### 3.2 增量合并算法

```csharp
private IReadOnlyDictionary<string, ConfigChange> ComputeMergedChanges(
    IReadOnlySet<int> changedLevels)
{
    var changes = new Dictionary<string, ConfigChange>();

    // 1. 收集所有可能受影响的键
    var affectedKeys = new HashSet<string>();
    foreach (var level in changedLevels)
    {
        var provider = _providers.First(p => p.Level == level).Provider;
        foreach (var key in GetProviderKeys(provider))
            affectedKeys.Add(key);
    }

    // 2. 对每个受影响的键，重新计算最终合并值
    foreach (var key in affectedKeys)
    {
        var oldValue = _mergedSnapshot.GetValueOrDefault(key);
        var newValue = ComputeFinalValue(key);

        // 3. 只有最终值真正变化时才记录
        if (!string.Equals(oldValue, newValue, StringComparison.Ordinal))
        {
            var changeType = (oldValue, newValue) switch
            {
                (null, not null) => ChangeType.Added,
                (not null, null) => ChangeType.Removed,
                _ => ChangeType.Modified
            };

            changes[key] = new ConfigChange
            {
                Key = key,
                OldValue = oldValue,
                NewValue = newValue,
                Type = changeType
            };

            // 更新快照
            if (newValue == null)
                _mergedSnapshot.TryRemove(key, out _);
            else
                _mergedSnapshot[key] = newValue;
        }
    }

    return changes;
}

private string? ComputeFinalValue(string key)
{
    // 从高优先级到低优先级遍历，返回第一个非空值
    foreach (var (_, provider) in _providers.OrderByDescending(p => p.Level))
    {
        if (provider.TryGet(key, out var value) && value != null)
            return value;
    }
    return null;
}
```

## 4. 层级覆盖逻辑

### 4.1 问题场景

假设有三层配置：
- Level 1 (低): `{ "Timeout": "30" }`
- Level 2 (中): `{ "Timeout": "60" }`
- Level 3 (高): `{ "Timeout": "90" }`

最终合并值：`Timeout = 90`

**场景1**: Level 1 的 Timeout 从 30 改为 45
- Level 3 仍然覆盖，最终值仍为 90
- **不应触发变更通知**

**场景2**: Level 3 的 Timeout 从 90 改为 120
- 最终值从 90 变为 120
- **应触发变更通知**

**场景3**: Level 3 删除 Timeout 配置
- 最终值从 90 变为 60 (Level 2 的值)
- **应触发变更通知**

### 4.2 实现保证

通过 `ComputeFinalValue()` 方法，始终从高优先级向低优先级查找，确保：
1. 只有最终合并值变化时才触发通知
2. 低层级的变化如果被高层级覆盖，不会产生通知

## 5. 性能优化策略

### 5.1 防抖 (Debouncing)

```csharp
private void OnSourceChanged(int level)
{
    lock (_lock)
    {
        _pendingChangeLevels.Add(level);
        _debounceTimer.Change(DebounceMs, Timeout.Infinite);
    }
}
```

**优点**：
- 批量文件保存时，多次快速变化合并为一次处理
- 减少不必要的重复计算

### 5.2 增量加载

只重新加载发生变化的配置源，而非全部重载：

```csharp
private void ProcessPendingChanges()
{
    HashSet<int> levelsToProcess;
    lock (_lock)
    {
        levelsToProcess = new HashSet<int>(_pendingChangeLevels);
        _pendingChangeLevels.Clear();
    }

    // 只加载变化的层级
    foreach (var level in levelsToProcess)
    {
        var provider = _providers.First(p => p.Level == level).Provider;
        provider.Load();
    }

    // 增量计算变更
    var changes = ComputeMergedChanges(levelsToProcess);

    if (changes.Count > 0)
        OnMergedChanges?.Invoke(changes);
}
```

### 5.3 快照缓存

维护最终合并值的快照，避免每次查询都遍历所有层级：

```csharp
private readonly ConcurrentDictionary<string, string?> _mergedSnapshot;
```

## 6. API 设计

### 6.1 新增接口

```csharp
public interface ICfgRoot : IDisposable, IAsyncDisposable
{
    // ... 现有方法 ...

    /// <summary>
    /// 转换为支持动态重载的 Microsoft Configuration
    /// </summary>
    /// <param name="options">动态重载选项</param>
    IConfigurationRoot ToMicrosoftConfiguration(DynamicReloadOptions? options = null);

    /// <summary>
    /// 获取配置变更的可观察序列
    /// </summary>
    IObservable<ConfigChangeEvent> ConfigChanges { get; }
}

public sealed class DynamicReloadOptions
{
    /// <summary>
    /// 防抖时间窗口（毫秒），默认 100ms
    /// </summary>
    public int DebounceMs { get; set; } = 100;

    /// <summary>
    /// 是否启用动态重载，默认 true
    /// </summary>
    public bool EnableDynamicReload { get; set; } = true;
}

public sealed class ConfigChangeEvent
{
    public IReadOnlyDictionary<string, ConfigChange> Changes { get; init; }
    public DateTimeOffset Timestamp { get; init; }
}
```

### 6.2 使用示例

```csharp
// 构建配置
var cfg = new CfgBuilder()
    .AddJson("appsettings.json", level: 1, writeable: false)
    .AddJson("appsettings.local.json", level: 2, writeable: true)
    .AddEnvironmentVariables(level: 3)
    .Build();

// 获取支持动态重载的 Microsoft Configuration
var msConfig = cfg.ToMicrosoftConfiguration(new DynamicReloadOptions
{
    DebounceMs = 200
});

// 方式1：使用 IChangeToken
ChangeToken.OnChange(
    () => msConfig.GetReloadToken(),
    () => Console.WriteLine("配置已更新"));

// 方式2：使用 Rx 订阅
cfg.ConfigChanges.Subscribe(e =>
{
    foreach (var (key, change) in e.Changes)
    {
        Console.WriteLine($"[{change.Type}] {key}: {change.OldValue} -> {change.NewValue}");
    }
});
```

## 7. 实现步骤

### 步骤 1：创建 ConfigChange 相关类型
- 文件：`Apq.Cfg/Changes/ConfigChange.cs`
- 文件：`Apq.Cfg/Changes/ConfigChangeEvent.cs`
- 文件：`Apq.Cfg/Changes/ChangeType.cs`

### 步骤 2：实现 ChangeCoordinator
- 文件：`Apq.Cfg/Internal/ChangeCoordinator.cs`
- 实现防抖逻辑
- 实现增量合并算法
- 实现层级覆盖检测

### 步骤 3：实现 MergedConfigurationProvider
- 文件：`Apq.Cfg/Internal/MergedConfigurationProvider.cs`
- 继承 `ConfigurationProvider`
- 实现 `IChangeToken` 支持
- 实现增量更新方法

### 步骤 4：实现 MergedConfigurationSource
- 文件：`Apq.Cfg/Internal/MergedConfigurationSource.cs`
- 实现 `IConfigurationSource`
- 创建 `MergedConfigurationProvider` 实例

### 步骤 5：修改 ICfgRoot 接口
- 添加 `DynamicReloadOptions` 参数重载
- 添加 `ConfigChanges` 属性

### 步骤 6：修改 MergedCfgRoot 实现
- 集成 `ChangeCoordinator`
- 实现新的 `ToMicrosoftConfiguration` 重载
- 实现 `ConfigChanges` 可观察序列

### 步骤 7：添加单元测试
- 测试防抖功能
- 测试增量更新
- 测试层级覆盖逻辑
- 测试多源场景

## 8. 注意事项

### 8.1 线程安全

- `ChangeCoordinator` 内部使用锁保护共享状态
- `ConcurrentDictionary` 用于快照存储
- 事件触发在独立线程，避免阻塞源变更检测

### 8.2 内存管理

- 正确实现 `IDisposable`，释放所有 `IChangeToken` 注册
- 取消订阅所有事件处理器
- 停止防抖计时器

### 8.3 异常处理

- 单个源加载失败不应影响其他源
- 变更处理异常应记录日志但不中断流程

## 9. 总结

本方案通过以下机制解决了动态配置重载的核心问题：

| 问题 | 解决方案 |
|------|----------|
| 性能下降 | 防抖 + 增量加载 + 快照缓存 |
| 层级覆盖 | 最终值比较，只通知真正变化 |
| 多源支持 | ChangeCoordinator 统一协调 |
| API 兼容 | 保持现有接口，新增可选参数 |

该设计在保持 API 简洁的同时，提供了高效、准确的动态配置重载能力。
