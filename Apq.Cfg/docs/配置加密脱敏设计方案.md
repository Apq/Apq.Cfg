# Apq.Cfg 配置加密脱敏设计方案

## 1. 设计目标

### 1.1 核心需求
- **加密**：敏感配置值（如数据库密码、API密钥）在存储时加密，读取时自动解密
- **脱敏**：日志输出、调试显示时自动隐藏敏感信息
- **零侵入**：不修改现有配置文件格式，通过约定标记敏感配置
- **可扩展**：支持多种加密算法，用户可自定义

### 1.2 架构约束
- **Apq.Cfg 核心库不依赖任何加密扩展包**
- 加密/脱敏功能通过独立扩展包提供
- 使用接口抽象和依赖注入实现解耦

### 1.3 加密算法实现策略

为了简化包管理和减少用户的依赖复杂度，我们采用以下策略：

- **Apq.Cfg.Crypto 项目**：集成 `BouncyCastle.Cryptography` 包，直接实现所有可通过 BouncyCastle 支持的加密算法（如 AES-GCM、AES-CBC、ChaCha20-Poly1305、RSA、SM4、Triple DES 等）
- **独立扩展项目**：仅用于实现需要特定平台或框架依赖的算法（如 `Apq.Cfg.Crypto.DataProtection` 依赖 ASP.NET Core Data Protection）
- **用户自定义扩展**：用户可以创建自己的扩展项目，实现 `ICryptoProvider` 接口来支持自定义加密算法或集成第三方密钥管理服务

## 2. 架构设计

### 2.1 依赖关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户应用程序                              │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ Apq.Cfg.Crypto  │  │ Apq.Cfg.Crypto  │  │   用户自定义     │  │
│  │  .DataProtection│  │    (内置算法)    │  │   扩展项目       │  │
│  │  (平台特定)      │  │  BouncyCastle   │  │                 │  │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘  │
│           │                    │                    │           │
│           └────────────────────┼────────────────────┘           │
│                                │                                │
│                    ┌───────────▼───────────┐                    │
│                    │      Apq.Cfg          │                    │
│                    │   (核心配置库)         │                    │
│                    │   定义接口抽象         │                    │
│                    └───────────────────────┘                    │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 核心接口设计（位于 Apq.Cfg）

```csharp
// Apq.Cfg/Security/IValueTransformer.cs
namespace Apq.Cfg.Security;

/// <summary>
/// 配置值转换器接口，用于加密/解密、脱敏等场景
/// </summary>
public interface IValueTransformer
{
    /// <summary>
    /// 转换器名称，用于标识
    /// </summary>
    string Name { get; }
    
    /// <summary>
    /// 优先级，数值越大优先级越高
    /// </summary>
    int Priority { get; }
    
    /// <summary>
    /// 判断是否应该处理该键
    /// </summary>
    bool ShouldTransform(string key, string? value);
    
    /// <summary>
    /// 读取时转换（如解密）
    /// </summary>
    string? TransformOnRead(string key, string? value);
    
    /// <summary>
    /// 写入时转换（如加密）
    /// </summary>
    string? TransformOnWrite(string key, string? value);
}

// Apq.Cfg/Security/IValueMasker.cs
namespace Apq.Cfg.Security;

/// <summary>
/// 配置值脱敏器接口，用于日志输出等场景
/// </summary>
public interface IValueMasker
{
    /// <summary>
    /// 判断是否应该脱敏该键
    /// </summary>
    bool ShouldMask(string key);
    
    /// <summary>
    /// 脱敏处理
    /// </summary>
    string Mask(string key, string? value);
}

// Apq.Cfg/Security/ValueTransformerOptions.cs
namespace Apq.Cfg.Security;

/// <summary>
/// 值转换器配置选项
/// </summary>
public class ValueTransformerOptions
{
    /// <summary>
    /// 是否启用值转换，默认 true
    /// </summary>
    public bool Enabled { get; set; } = true;
    
    /// <summary>
    /// 敏感键模式列表（支持通配符）
    /// </summary>
    public List<string> SensitiveKeyPatterns { get; set; } = new()
    {
        "*Password*",
        "*Secret*",
        "*ApiKey*",
        "*ConnectionString*",
        "*Credential*",
        "*Token*"
    };
    
    /// <summary>
    /// 加密值前缀标记（使用花括号避免与配置节分隔符 : 混淆）
    /// </summary>
    public string EncryptedPrefix { get; set; } = "{ENC}";
}
```

### 2.3 CfgBuilder 扩展点

```csharp
// Apq.Cfg/CfgBuilder.cs 新增
public sealed class CfgBuilder
{
    private readonly List<IValueTransformer> _transformers = new();
    private readonly List<IValueMasker> _maskers = new();
    private ValueTransformerOptions _transformerOptions = new();
    
    // ... 现有代码 ...
    
    /// <summary>
    /// 添加值转换器（供扩展包使用）
    /// </summary>
    public CfgBuilder AddValueTransformer(IValueTransformer transformer)
    {
        _transformers.Add(transformer);
        return this;
    }
    
    /// <summary>
    /// 添加值脱敏器（供扩展包使用）
    /// </summary>
    public CfgBuilder AddValueMasker(IValueMasker masker)
    {
        _maskers.Add(masker);
        return this;
    }
    
    /// <summary>
    /// 配置值转换选项
    /// </summary>
    public CfgBuilder ConfigureValueTransformer(Action<ValueTransformerOptions> configure)
    {
        configure(_transformerOptions);
        return this;
    }
    
    public ICfgRoot Build()
    {
        var transformerChain = _transformers.Count > 0 
            ? new ValueTransformerChain(_transformers, _transformerOptions)
            : null;
        var maskerChain = _maskers.Count > 0
            ? new ValueMaskerChain(_maskers)
            : null;
            
        return new MergedCfgRoot(_sources, transformerChain, maskerChain);
    }
}
```

### 2.4 内部实现（位于 Apq.Cfg）

```csharp
// Apq.Cfg/Internal/ValueTransformerChain.cs
namespace Apq.Cfg.Internal;

internal sealed class ValueTransformerChain
{
    private readonly IValueTransformer[] _transformers;
    private readonly ValueTransformerOptions _options;
    
    public ValueTransformerChain(
        IEnumerable<IValueTransformer> transformers,
        ValueTransformerOptions options)
    {
        _transformers = transformers.OrderByDescending(t => t.Priority).ToArray();
        _options = options;
    }
    
    public string? TransformOnRead(string key, string? value)
    {
        if (!_options.Enabled || value == null)
            return value;
            
        foreach (var transformer in _transformers)
        {
            if (transformer.ShouldTransform(key, value))
            {
                value = transformer.TransformOnRead(key, value);
            }
        }
        return value;
    }
    
    public string? TransformOnWrite(string key, string? value)
    {
        if (!_options.Enabled || value == null)
            return value;
            
        foreach (var transformer in _transformers)
        {
            if (transformer.ShouldTransform(key, value))
            {
                value = transformer.TransformOnWrite(key, value);
            }
        }
        return value;
    }
}

// Apq.Cfg/Internal/ValueMaskerChain.cs
namespace Apq.Cfg.Internal;

internal sealed class ValueMaskerChain
{
    private readonly IValueMasker[] _maskers;
    
    public ValueMaskerChain(IEnumerable<IValueMasker> maskers)
    {
        _maskers = maskers.ToArray();
    }
    
    public string Mask(string key, string? value)
    {
        if (value == null)
            return "[null]";
            
        foreach (var masker in _maskers)
        {
            if (masker.ShouldMask(key))
            {
                return masker.Mask(key, value);
            }
        }
        return value;
    }
}
```

## 3. 内置加密算法支持

### 3.1 Apq.Cfg.Crypto 内置算法

Apq.Cfg.Crypto 项目依赖 `BouncyCastle.Cryptography` 包，直接内置实现以下所有加密算法：

| 算法 | 类名 | 安全级别 | 跨平台 | 适用场景 |
|------|------|----------|--------|----------|
| AES-GCM | `AesGcmCryptoProvider` | ⭐⭐⭐⭐⭐ | ✅ | 推荐首选，认证加密 |
| AES-CBC | `AesCbcCryptoProvider` | ⭐⭐⭐⭐ | ✅ | 兼容性好，需配合 HMAC |
| ChaCha20-Poly1305 | `ChaCha20CryptoProvider` | ⭐⭐⭐⭐⭐ | ✅ | 高性能，移动端友好 |
| RSA | `RsaCryptoProvider` | ⭐⭐⭐⭐ | ✅ | 非对称加密，密钥分发 |
| Triple DES | `TripleDesCryptoProvider` | ⭐⭐⭐ | ✅ | 遗留系统兼容 |
| SM4 | `Sm4CryptoProvider` | ⭐⭐⭐⭐ | ✅ | 国密算法，合规要求 |

### 3.2 独立扩展包（平台特定）

以下算法因依赖特定平台或框架，需要独立的扩展包：

| 算法 | 包名 | 依赖 | 适用场景 |
|------|------|------|----------|
| Data Protection | `Apq.Cfg.Crypto.DataProtection` | ASP.NET Core | ASP.NET Core 集成 |

### 3.3 算法选择指南

```
                    ┌─────────────────────────────────────┐
                    │         选择加密算法                 │
                    └─────────────────┬───────────────────┘
                                      │
                    ┌─────────────────▼───────────────────┐
                    │     是否需要非对称加密？              │
                    └─────────────────┬───────────────────┘
                           是 │              │ 否
                    ┌────────▼────────┐     │
                    │      RSA        │     │
                    │  (密钥分发场景)  │     │
                    └─────────────────┘     │
                                           │
                    ┌─────────────────────▼───────────────┐
                    │     是否有国密合规要求？              │
                    └─────────────────┬───────────────────┘
                           是 │              │ 否
                    ┌────────▼────────┐     │
                    │      SM4        │     │
                    │   (国密算法)     │     │
                    └─────────────────┘     │
                                           │
                    ┌─────────────────────▼───────────────┐
                    │     是否需要高性能/移动端？           │
                    └─────────────────┬───────────────────┘
                           是 │              │ 否
                    ┌────────▼────────┐     │
                    │ ChaCha20-Poly1305│     │
                    │   (高性能)       │     │
                    └─────────────────┘     │
                                           │
                    ┌─────────────────────▼───────────────┐
                    │     是否使用 ASP.NET Core？          │
                    └─────────────────┬───────────────────┘
                           是 │              │ 否
                    ┌────────▼────────┐     │
                    │ Data Protection │     │
                    │  (框架集成)      │     │
                    └─────────────────┘     │
                                           │
                              ┌────────────▼────────────┐
                              │        AES-GCM          │
                              │    (推荐默认选择)        │
                              └─────────────────────────┘
```

## 4. Apq.Cfg.Crypto 包设计

### 4.1 包结构

Apq.Cfg.Crypto 是加密功能的核心包，依赖 `BouncyCastle.Cryptography`，内置实现所有常用加密算法：

```
Apq.Cfg.Crypto/
├── ICryptoProvider.cs              # 加密提供者接口
├── EncryptionTransformer.cs        # 加密值转换器
├── EncryptionOptions.cs            # 加密选项
├── SensitiveMasker.cs              # 敏感值脱敏器
├── MaskingOptions.cs               # 脱敏选项
├── CfgBuilderExtensions.cs         # CfgBuilder 扩展方法
└── Providers/                      # 内置加密提供者
    ├── AesGcmCryptoProvider.cs     # AES-GCM 实现
    ├── AesCbcCryptoProvider.cs     # AES-CBC 实现
    ├── ChaCha20CryptoProvider.cs   # ChaCha20-Poly1305 实现
    ├── RsaCryptoProvider.cs        # RSA 实现
    ├── Sm4CryptoProvider.cs        # SM4 国密实现
    └── TripleDesCryptoProvider.cs  # Triple DES 实现
```

### 4.2 核心接口

```csharp
// Apq.Cfg.Crypto/ICryptoProvider.cs
namespace Apq.Cfg.Crypto;

/// <summary>
/// 加密提供者接口
/// </summary>
public interface ICryptoProvider
{
    /// <summary>
    /// 加密
    /// </summary>
    string Encrypt(string plainText);
    
    /// <summary>
    /// 解密
    /// </summary>
    string Decrypt(string cipherText);
}
```

### 4.3 加密值转换器

```csharp
// Apq.Cfg.Crypto/EncryptionTransformer.cs
namespace Apq.Cfg.Crypto;

/// <summary>
/// 加密值转换器
/// </summary>
public class EncryptionTransformer : IValueTransformer
{
    private readonly ICryptoProvider _provider;
    private readonly EncryptionOptions _options;
    
    public string Name => "Encryption";
    public int Priority => 100;
    
    public EncryptionTransformer(ICryptoProvider provider, EncryptionOptions? options = null)
    {
        _provider = provider;
        _options = options ?? new EncryptionOptions();
    }
    
    public bool ShouldTransform(string key, string? value)
    {
        // 读取时：检查是否有加密前缀
        if (value?.StartsWith(_options.EncryptedPrefix) == true)
            return true;
            
        // 写入时：检查是否匹配敏感键模式
        return _options.SensitiveKeyPatterns.Any(pattern => 
            MatchPattern(key, pattern));
    }
    
    public string? TransformOnRead(string key, string? value)
    {
        if (value == null)
            return null;
            
        if (!value.StartsWith(_options.EncryptedPrefix))
            return value;
            
        var cipherText = value.Substring(_options.EncryptedPrefix.Length);
        return _provider.Decrypt(cipherText);
    }
    
    public string? TransformOnWrite(string key, string? value)
    {
        if (value == null)
            return null;
            
        // 已加密的不重复加密
        if (value.StartsWith(_options.EncryptedPrefix))
            return value;
            
        // 检查是否需要加密
        if (!_options.SensitiveKeyPatterns.Any(p => MatchPattern(key, p)))
            return value;
            
        var cipherText = _provider.Encrypt(value);
        return _options.EncryptedPrefix + cipherText;
    }
    
    private static bool MatchPattern(string key, string pattern)
    {
        // 简单通配符匹配实现
        var regex = "^" + Regex.Escape(pattern)
            .Replace("\\*", ".*")
            .Replace("\\?", ".") + "$";
        return Regex.IsMatch(key, regex, RegexOptions.IgnoreCase);
    }
}
```

### 4.4 加密选项

```csharp
// Apq.Cfg.Crypto/EncryptionOptions.cs
namespace Apq.Cfg.Crypto;

public class EncryptionOptions
{
    /// <summary>
    /// 敏感键模式（支持通配符 * 和 ?）
    /// </summary>
    public List<string> SensitiveKeyPatterns { get; set; } = new()
    {
        "*Password*",
        "*Secret*",
        "*ApiKey*",
        "*ConnectionString*",
        "*Credential*",
        "*Token*"
    };
    
    /// <summary>
    /// 加密值前缀标记（使用花括号避免与配置节分隔符 : 混淆）
    /// </summary>
    public string EncryptedPrefix { get; set; } = "{ENC}";
    
    /// <summary>
    /// 是否在写入时自动加密匹配的敏感键
    /// </summary>
    public bool AutoEncryptOnWrite { get; set; } = true;
}
```

### 4.5 脱敏器

```csharp
// Apq.Cfg.Crypto/SensitiveMasker.cs
namespace Apq.Cfg.Crypto;

/// <summary>
/// 敏感值脱敏器
/// </summary>
public class SensitiveMasker : IValueMasker
{
    private readonly MaskingOptions _options;
    
    public SensitiveMasker(MaskingOptions? options = null)
    {
        _options = options ?? new MaskingOptions();
    }
    
    public bool ShouldMask(string key)
    {
        return _options.SensitiveKeyPatterns.Any(pattern => 
            MatchPattern(key, pattern));
    }
    
    public string Mask(string key, string? value)
    {
        if (value == null)
            return _options.NullPlaceholder;
            
        if (value.Length <= _options.VisibleChars * 2)
            return _options.MaskString;
            
        return value.Substring(0, _options.VisibleChars) 
            + _options.MaskString 
            + value.Substring(value.Length - _options.VisibleChars);
    }
    
    private static bool MatchPattern(string key, string pattern)
    {
        var regex = "^" + Regex.Escape(pattern)
            .Replace("\\*", ".*")
            .Replace("\\?", ".") + "$";
        return Regex.IsMatch(key, regex, RegexOptions.IgnoreCase);
    }
}

// Apq.Cfg.Crypto/MaskingOptions.cs
namespace Apq.Cfg.Crypto;

public class MaskingOptions
{
    /// <summary>
    /// 敏感键模式
    /// </summary>
    public List<string> SensitiveKeyPatterns { get; set; } = new()
    {
        "*Password*",
        "*Secret*",
        "*ApiKey*",
        "*ConnectionString*",
        "*Credential*",
        "*Token*"
    };
    
    /// <summary>
    /// 脱敏字符串
    /// </summary>
    public string MaskString { get; set; } = "***";
    
    /// <summary>
    /// 保留可见字符数
    /// </summary>
    public int VisibleChars { get; set; } = 3;
    
    /// <summary>
    /// null 值占位符
    /// </summary>
    public string NullPlaceholder { get; set; } = "[null]";
}
```

### 4.6 CfgBuilder 扩展方法

```csharp
// Apq.Cfg.Crypto/CfgBuilderExtensions.cs
namespace Apq.Cfg.Crypto;

public static class CfgBuilderExtensions
{
    /// <summary>
    /// 添加加密支持
    /// </summary>
    public static CfgBuilder AddEncryption(
        this CfgBuilder builder,
        ICryptoProvider provider,
        Action<EncryptionOptions>? configure = null)
    {
        var options = new EncryptionOptions();
        configure?.Invoke(options);
        
        builder.AddValueTransformer(new EncryptionTransformer(provider, options));
        return builder;
    }
    
    /// <summary>
    /// 添加敏感值脱敏
    /// </summary>
    public static CfgBuilder AddSensitiveMasking(
        this CfgBuilder builder,
        Action<MaskingOptions>? configure = null)
    {
        var options = new MaskingOptions();
        configure?.Invoke(options);
        
        builder.AddValueMasker(new SensitiveMasker(options));
        return builder;
    }
    
    // ==================== 内置算法扩展方法 ====================
    
    /// <summary>
    /// 添加 AES-GCM 加密支持
    /// </summary>
    public static CfgBuilder AddAesGcmEncryption(
        this CfgBuilder builder,
        string base64Key,
        Action<EncryptionOptions>? configure = null)
    {
        var provider = new AesGcmCryptoProvider(base64Key);
        return builder.AddEncryption(provider, configure);
    }
    
    /// <summary>
    /// 添加 AES-GCM 加密支持（从环境变量读取密钥）
    /// </summary>
    public static CfgBuilder AddAesGcmEncryptionFromEnv(
        this CfgBuilder builder,
        string envVarName = "APQ_CFG_ENCRYPTION_KEY",
        Action<EncryptionOptions>? configure = null)
    {
        var key = Environment.GetEnvironmentVariable(envVarName)
            ?? throw new InvalidOperationException($"环境变量 {envVarName} 未设置");
        return builder.AddAesGcmEncryption(key, configure);
    }
    
    /// <summary>
    /// 添加 AES-CBC 加密支持
    /// </summary>
    public static CfgBuilder AddAesCbcEncryption(
        this CfgBuilder builder,
        string base64EncryptionKey,
        string base64HmacKey,
        Action<EncryptionOptions>? configure = null)
    {
        var provider = new AesCbcCryptoProvider(base64EncryptionKey, base64HmacKey);
        return builder.AddEncryption(provider, configure);
    }
    
    /// <summary>
    /// 添加 ChaCha20-Poly1305 加密支持
    /// </summary>
    public static CfgBuilder AddChaCha20Encryption(
        this CfgBuilder builder,
        string base64Key,
        Action<EncryptionOptions>? configure = null)
    {
        var provider = new ChaCha20CryptoProvider(base64Key);
        return builder.AddEncryption(provider, configure);
    }
    
    /// <summary>
    /// 添加 RSA 加密支持（从 PEM 文件）
    /// </summary>
    public static CfgBuilder AddRsaEncryption(
        this CfgBuilder builder,
        string pemFilePath,
        Action<EncryptionOptions>? configure = null)
    {
        var pem = File.ReadAllText(pemFilePath);
        var provider = RsaCryptoProvider.FromPem(pem);
        return builder.AddEncryption(provider, configure);
    }
    
    /// <summary>
    /// 添加 RSA 加密支持（从 PEM 字符串）
    /// </summary>
    public static CfgBuilder AddRsaEncryptionFromPem(
        this CfgBuilder builder,
        string pem,
        Action<EncryptionOptions>? configure = null)
    {
        var provider = RsaCryptoProvider.FromPem(pem);
        return builder.AddEncryption(provider, configure);
    }
    
    /// <summary>
    /// 添加 SM4 国密加密支持
    /// </summary>
    public static CfgBuilder AddSm4Encryption(
        this CfgBuilder builder,
        string base64Key,
        Sm4Mode mode = Sm4Mode.CBC,
        Action<EncryptionOptions>? configure = null)
    {
        var provider = new Sm4CryptoProvider(base64Key, mode);
        return builder.AddEncryption(provider, configure);
    }
    
    /// <summary>
    /// 添加 Triple DES 加密支持（仅用于遗留系统兼容）
    /// </summary>
    [Obsolete("Triple DES is considered weak. Use AES-GCM for new projects.")]
    public static CfgBuilder AddTripleDesEncryption(
        this CfgBuilder builder,
        string base64Key,
        Action<EncryptionOptions>? configure = null)
    {
        var provider = new TripleDesCryptoProvider(base64Key);
        return builder.AddEncryption(provider, configure);
    }
}
```

## 5. 内置加密提供者实现

### 5.1 AES-GCM 加密提供者

```csharp
// Apq.Cfg.Crypto/Providers/AesGcmCryptoProvider.cs
namespace Apq.Cfg.Crypto.Providers;

using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;

/// <summary>
/// AES-GCM 加密提供者（使用 BouncyCastle 实现）
/// </summary>
public class AesGcmCryptoProvider : ICryptoProvider, IDisposable
{
    private readonly byte[] _key;
    private const int NonceSize = 12;
    private const int TagSize = 16;
    
    public AesGcmCryptoProvider(byte[] key)
    {
        if (key.Length != 16 && key.Length != 24 && key.Length != 32)
            throw new ArgumentException("Key must be 128, 192, or 256 bits");
        _key = key;
    }
    
    public AesGcmCryptoProvider(string base64Key)
        : this(Convert.FromBase64String(base64Key))
    {
    }
    
    public string Encrypt(string plainText)
    {
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var nonce = new byte[NonceSize];
        var random = new SecureRandom();
        random.NextBytes(nonce);
        
        var cipher = new GcmBlockCipher(new AesEngine());
        var parameters = new AeadParameters(new KeyParameter(_key), TagSize * 8, nonce);
        cipher.Init(true, parameters);
        
        var cipherBytes = new byte[cipher.GetOutputSize(plainBytes.Length)];
        var len = cipher.ProcessBytes(plainBytes, 0, plainBytes.Length, cipherBytes, 0);
        cipher.DoFinal(cipherBytes, len);
        
        // 格式: nonce(12) + cipher+tag
        var result = new byte[nonce.Length + cipherBytes.Length];
        Buffer.BlockCopy(nonce, 0, result, 0, nonce.Length);
        Buffer.BlockCopy(cipherBytes, 0, result, nonce.Length, cipherBytes.Length);
        
        return Convert.ToBase64String(result);
    }
    
    public string Decrypt(string cipherText)
    {
        var data = Convert.FromBase64String(cipherText);
        
        var nonce = new byte[NonceSize];
        var cipherBytes = new byte[data.Length - NonceSize];
        
        Buffer.BlockCopy(data, 0, nonce, 0, NonceSize);
        Buffer.BlockCopy(data, NonceSize, cipherBytes, 0, cipherBytes.Length);
        
        var cipher = new GcmBlockCipher(new AesEngine());
        var parameters = new AeadParameters(new KeyParameter(_key), TagSize * 8, nonce);
        cipher.Init(false, parameters);
        
        var plainBytes = new byte[cipher.GetOutputSize(cipherBytes.Length)];
        var len = cipher.ProcessBytes(cipherBytes, 0, cipherBytes.Length, plainBytes, 0);
        cipher.DoFinal(plainBytes, len);
        
        return Encoding.UTF8.GetString(plainBytes);
    }
    
    public void Dispose()
    {
        Array.Clear(_key, 0, _key.Length);
    }
}
```

### 5.2 SM4 国密加密提供者

```csharp
// Apq.Cfg.Crypto/Providers/Sm4CryptoProvider.cs
namespace Apq.Cfg.Crypto.Providers;

using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Paddings;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;

/// <summary>
/// SM4 国密算法加密提供者（使用 BouncyCastle 实现）
/// </summary>
public class Sm4CryptoProvider : ICryptoProvider, IDisposable
{
    private readonly byte[] _key;
    private readonly Sm4Mode _mode;
    private const int BlockSize = 16;
    
    public Sm4CryptoProvider(byte[] key, Sm4Mode mode = Sm4Mode.CBC)
    {
        if (key.Length != 16)
            throw new ArgumentException("SM4 key must be 128 bits");
        _key = key;
        _mode = mode;
    }
    
    public Sm4CryptoProvider(string base64Key, Sm4Mode mode = Sm4Mode.CBC)
        : this(Convert.FromBase64String(base64Key), mode)
    {
    }
    
    public string Encrypt(string plainText)
    {
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var iv = new byte[BlockSize];
        var random = new SecureRandom();
        random.NextBytes(iv);
        
        var cipher = CreateCipher(true, iv);
        var cipherBytes = new byte[cipher.GetOutputSize(plainBytes.Length)];
        var len = cipher.ProcessBytes(plainBytes, 0, plainBytes.Length, cipherBytes, 0);
        cipher.DoFinal(cipherBytes, len);
        
        // 格式: IV(16) + cipher
        var result = new byte[iv.Length + cipherBytes.Length];
        Buffer.BlockCopy(iv, 0, result, 0, iv.Length);
        Buffer.BlockCopy(cipherBytes, 0, result, iv.Length, cipherBytes.Length);
        
        return Convert.ToBase64String(result);
    }
    
    public string Decrypt(string cipherText)
    {
        var data = Convert.FromBase64String(cipherText);
        
        var iv = new byte[BlockSize];
        var cipherBytes = new byte[data.Length - BlockSize];
        Buffer.BlockCopy(data, 0, iv, 0, BlockSize);
        Buffer.BlockCopy(data, BlockSize, cipherBytes, 0, cipherBytes.Length);
        
        var cipher = CreateCipher(false, iv);
        var plainBytes = new byte[cipher.GetOutputSize(cipherBytes.Length)];
        var len = cipher.ProcessBytes(cipherBytes, 0, cipherBytes.Length, plainBytes, 0);
        len += cipher.DoFinal(plainBytes, len);
        
        return Encoding.UTF8.GetString(plainBytes, 0, len);
    }
    
    private IBufferedCipher CreateCipher(bool forEncryption, byte[] iv)
    {
        var engine = new SM4Engine();
        IBufferedCipher cipher;
        
        switch (_mode)
        {
            case Sm4Mode.CBC:
                cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(engine), new Pkcs7Padding());
                cipher.Init(forEncryption, new ParametersWithIV(new KeyParameter(_key), iv));
                break;
            case Sm4Mode.ECB:
                cipher = new PaddedBufferedBlockCipher(engine, new Pkcs7Padding());
                cipher.Init(forEncryption, new KeyParameter(_key));
                break;
            default:
                throw new NotSupportedException($"SM4 mode {_mode} is not supported");
        }
        
        return cipher;
    }
    
    public void Dispose()
    {
        Array.Clear(_key, 0, _key.Length);
    }
}

public enum Sm4Mode
{
    CBC,
    ECB
}
```

### 5.3 其他内置加密提供者

其他加密提供者（AES-CBC、ChaCha20-Poly1305、RSA、Triple DES）的实现方式类似，都使用 BouncyCastle 库实现。详细代码请参考项目源码。

## 6. 独立扩展包：Apq.Cfg.Crypto.DataProtection

### 6.1 包结构

```
Apq.Cfg.Crypto.DataProtection/
├── DataProtectionCryptoProvider.cs
└── CfgBuilderExtensions.cs
```

### 6.2 实现

```csharp
// Apq.Cfg.Crypto.DataProtection/DataProtectionCryptoProvider.cs
namespace Apq.Cfg.Crypto.DataProtection;

using Microsoft.AspNetCore.DataProtection;

/// <summary>
/// 使用 ASP.NET Core Data Protection 的加密提供者
/// </summary>
public class DataProtectionCryptoProvider : ICryptoProvider
{
    private readonly IDataProtector _protector;
    
    public DataProtectionCryptoProvider(IDataProtectionProvider provider, string purpose = "Apq.Cfg")
    {
        _protector = provider.CreateProtector(purpose);
    }
    
    public string Encrypt(string plainText)
    {
        return _protector.Protect(plainText);
    }
    
    public string Decrypt(string cipherText)
    {
        return _protector.Unprotect(cipherText);
    }
}

// Apq.Cfg.Crypto.DataProtection/CfgBuilderExtensions.cs
namespace Apq.Cfg.Crypto.DataProtection;

public static class CfgBuilderExtensions
{
    /// <summary>
    /// 添加 Data Protection 加密支持
    /// </summary>
    public static CfgBuilder AddDataProtectionEncryption(
        this CfgBuilder builder,
        IDataProtectionProvider provider,
        string purpose = "Apq.Cfg",
        Action<EncryptionOptions>? configure = null)
    {
        var cryptoProvider = new DataProtectionCryptoProvider(provider, purpose);
        return builder.AddEncryption(cryptoProvider, configure);
    }
}
```

## 7. 用户自定义扩展项目

用户可以创建自己的扩展项目来实现自定义加密算法或集成第三方密钥管理服务。

### 7.1 创建自定义扩展项目

1. 创建新的类库项目
2. 添加对 `Apq.Cfg.Crypto` 的引用
3. 实现 `ICryptoProvider` 接口
4. 创建 `CfgBuilder` 扩展方法

### 7.2 示例：集成 HashiCorp Vault

```csharp
// MyApp.Crypto.Vault/VaultTransitCryptoProvider.cs
namespace MyApp.Crypto.Vault;

using VaultSharp;
using VaultSharp.V1.AuthMethods.Token;

/// <summary>
/// 使用 HashiCorp Vault Transit 引擎的加密提供者
/// </summary>
public class VaultTransitCryptoProvider : ICryptoProvider, IDisposable
{
    private readonly IVaultClient _vaultClient;
    private readonly string _keyName;
    
    public VaultTransitCryptoProvider(string vaultAddress, string token, string keyName = "config-key")
    {
        var authMethod = new TokenAuthMethodInfo(token);
        var vaultClientSettings = new VaultClientSettings(vaultAddress, authMethod);
        _vaultClient = new VaultClient(vaultClientSettings);
        _keyName = keyName;
    }
    
    public string Encrypt(string plainText)
    {
        var response = _vaultClient.V1.Secrets.Transit.EncryptAsync(
            _keyName,
            new EncryptRequestOptions { PlainText = Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText)) }
        ).GetAwaiter().GetResult();
        
        return response.Data.CipherText;
    }
    
    public string Decrypt(string cipherText)
    {
        var response = _vaultClient.V1.Secrets.Transit.DecryptAsync(
            _keyName,
            new DecryptRequestOptions { CipherText = cipherText }
        ).GetAwaiter().GetResult();
        
        return Encoding.UTF8.GetString(Convert.FromBase64String(response.Data.PlainText));
    }
    
    public void Dispose()
    {
        // 清理资源
    }
}

// MyApp.Crypto.Vault/CfgBuilderExtensions.cs
namespace MyApp.Crypto.Vault;

public static class CfgBuilderExtensions
{
    /// <summary>
    /// 添加 Vault Transit 加密支持
    /// </summary>
    public static CfgBuilder AddVaultTransitEncryption(
        this CfgBuilder builder,
        string vaultAddress,
        string token,
        string keyName = "config-key",
        Action<EncryptionOptions>? configure = null)
    {
        var provider = new VaultTransitCryptoProvider(vaultAddress, token, keyName);
        return builder.AddEncryption(provider, configure);
    }
}
```

### 7.3 示例：集成 Azure Key Vault

```csharp
// MyApp.Crypto.Azure/AzureKeyVaultCryptoProvider.cs
namespace MyApp.Crypto.Azure;

using Azure.Identity;
using Azure.Security.KeyVault.Keys.Cryptography;

public class AzureKeyVaultCryptoProvider : ICryptoProvider
{
    private readonly CryptographyClient _cryptoClient;
    
    public AzureKeyVaultCryptoProvider(string keyVaultUrl, string keyName)
    {
        var credential = new DefaultAzureCredential();
        _cryptoClient = new CryptographyClient(new Uri($"{keyVaultUrl}/keys/{keyName}"), credential);
    }
    
    public string Encrypt(string plainText)
    {
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var result = _cryptoClient.Encrypt(EncryptionAlgorithm.RsaOaep256, plainBytes);
        return Convert.ToBase64String(result.Ciphertext);
    }
    
    public string Decrypt(string cipherText)
    {
        var cipherBytes = Convert.FromBase64String(cipherText);
        var result = _cryptoClient.Decrypt(EncryptionAlgorithm.RsaOaep256, cipherBytes);
        return Encoding.UTF8.GetString(result.Plaintext);
    }
}
```

### 7.4 自定义扩展最佳实践

1. **实现 IDisposable**：如果加密提供者持有需要释放的资源（如密钥、连接），应实现 IDisposable
2. **线程安全**：确保加密/解密方法是线程安全的
3. **异常处理**：妥善处理加密/解密失败的情况，提供有意义的错误信息
4. **密钥管理**：不要在代码中硬编码密钥，使用环境变量或密钥管理服务
5. **性能考虑**：对于远程加密服务（如 Vault、KMS），考虑添加缓存机制

## 8. 使用示例

### 8.1 基本使用

```csharp
// 配置文件 config.json
{
    "Database": {
        "ConnectionString": "{ENC}base64encodedciphertext...",
        "Password": "{ENC}base64encodedciphertext..."
    },
    "Api": {
        "Key": "{ENC}base64encodedciphertext..."
    }
}

// 程序代码
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: false)
    .AddAesGcmEncryptionFromEnv()  // 从环境变量读取密钥
    .AddSensitiveMasking()          // 添加脱敏支持
    .Build();

// 读取时自动解密
var connectionString = cfg["Database:ConnectionString"];

// 日志输出时自动脱敏
logger.LogInformation("连接字符串: {ConnectionString}", cfg.GetMasked("Database:ConnectionString"));
// 输出: 连接字符串: Ser***ion
```

### 8.2 使用不同算法

```csharp
// 使用 AES-GCM（推荐）
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: false)
    .AddAesGcmEncryption("base64key...")
    .Build();

// 使用 SM4 国密算法
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: false)
    .AddSm4Encryption("base64key...", Sm4Mode.CBC)
    .Build();

// 使用 RSA 非对称加密
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: false)
    .AddRsaEncryption("path/to/private.pem")
    .Build();

// 使用 Data Protection（ASP.NET Core）
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: false)
    .AddDataProtectionEncryption(dataProtectionProvider)
    .Build();
```

### 8.3 与 DI 集成

```csharp
// Program.cs
services.AddApqCfg(builder => builder
    .AddJson("config.json", level: 0, writeable: false)
    .AddAesGcmEncryptionFromEnv()
    .AddSensitiveMasking());

// 或者使用 Data Protection
services.AddDataProtection();
services.AddApqCfg((builder, sp) => builder
    .AddJson("config.json", level: 0, writeable: false)
    .AddDataProtectionEncryption(sp.GetRequiredService<IDataProtectionProvider>())
    .AddSensitiveMasking());
```

## 9. 包结构总结

```
Apq.Cfg                          # 核心库（定义接口）
├── Security/
│   ├── IValueTransformer.cs
│   ├── IValueMasker.cs
│   └── ValueTransformerOptions.cs
└── Internal/
    ├── ValueTransformerChain.cs
    └── ValueMaskerChain.cs

Apq.Cfg.Crypto                   # 加密核心包（依赖 BouncyCastle）
├── ICryptoProvider.cs
├── EncryptionTransformer.cs
├── EncryptionOptions.cs
├── SensitiveMasker.cs
├── MaskingOptions.cs
├── CfgBuilderExtensions.cs
└── Providers/
    ├── AesGcmCryptoProvider.cs
    ├── AesCbcCryptoProvider.cs
    ├── ChaCha20CryptoProvider.cs
    ├── RsaCryptoProvider.cs
    ├── Sm4CryptoProvider.cs
    └── TripleDesCryptoProvider.cs

Apq.Cfg.Crypto.DataProtection    # Data Protection 扩展（平台特定）
├── DataProtectionCryptoProvider.cs
└── CfgBuilderExtensions.cs

Apq.Cfg.Crypto.Tool              # 命令行工具
└── Program.cs
```

## 10. 依赖关系总结

| 包 | 依赖 |
|---|---|
| Apq.Cfg | 无加密依赖 |
| Apq.Cfg.Crypto | Apq.Cfg, BouncyCastle.Cryptography |
| Apq.Cfg.Crypto.DataProtection | Apq.Cfg.Crypto, Microsoft.AspNetCore.DataProtection |
| Apq.Cfg.Crypto.Tool | Apq.Cfg.Crypto |

**关键点**：
- Apq.Cfg 核心库只定义接口（`IValueTransformer`、`IValueMasker`），不包含任何加密实现
- Apq.Cfg.Crypto 依赖 BouncyCastle.Cryptography，内置实现所有常用加密算法
- 仅平台特定的算法（如 Data Protection）需要独立扩展包
- 用户可以创建自定义扩展项目实现特殊需求

## 11. 命令行工具

### 11.1 加密工具

```bash
# 安装工具
dotnet tool install -g Apq.Cfg.Crypto.Tool

# 生成密钥
apqenc generate-key --algorithm aes-gcm --bits 256

# 加密值
apqenc encrypt --algorithm aes-gcm --key "base64key..." --value "mySecret"
# 输出: {ENC}base64ciphertext...

# 解密值
apqenc decrypt --algorithm aes-gcm --key "base64key..." --value "{ENC}base64cipher..."

# 批量加密配置文件中的敏感值
apqenc encrypt-file --algorithm aes-gcm --key "base64key..." --file config.json --patterns "*Password*,*Secret*"
```

## 12. 安全最佳实践

### 12.1 密钥管理
- **不要**将加密密钥存储在配置文件中
- 使用环境变量、密钥管理服务（如 Azure Key Vault、HashiCorp Vault）
- 定期轮换密钥

### 12.2 加密算法选择
- 推荐使用 AES-GCM（认证加密）
- 避免使用 ECB 模式
- 使用足够长的密钥（256 位）

### 12.3 脱敏策略
- 日志中始终使用脱敏值
- 调试输出使用脱敏快照
- 异常消息中不包含敏感值
