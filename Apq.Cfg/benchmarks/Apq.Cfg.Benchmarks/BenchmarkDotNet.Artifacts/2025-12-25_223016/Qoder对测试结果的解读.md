# Apq.Cfg 性能测试结果（2025-12-25_223016）

**测试环境**：

- 系统：Windows 11 (10.0.26200.7462)
- SDK：.NET SDK 9.0.308
- 测试运行时：.NET 6.0.36、.NET 8.0.22、.NET 9.0.11
- CPU：支持 AVX-512F+CD+BW+DQ+VL+VBMI
- 测试日期：2025-12-25 22:30 左右本地运行

整体结论：本次测试结果与 2025-12-25 早前两次（001542 / 151849）趋势一致，**.NET 8.0 / 9.0 在几乎所有场景下都明显优于 .NET 6.0，且 .NET 9.0 在类型转换和复杂场景上略有额外优势**；各配置格式之间的相对排序也保持稳定。

---

## 1. 读写基准测试 (ReadWriteBenchmarks)

本次测试的 `*-report-github.md` 采用压缩汇总，只保留了每组场景的平均耗时（Mean），但结合上一轮（151849）的详细数值，可以得出：

- 单次读取/写入仍然稳定在 **20 ns 级别**，属于极低延迟操作；
- .NET 8.0 / 9.0 相比 .NET 6.0，在 `Get` / `Set` / `Exists` 等基本操作上仍有 **30–40% 左右的性能优势**；
- `GetInt` 等类型转换型读取，.NET 9.0 相比 .NET 6.0 提升更明显，整体仍维持在 **80–90 ns 以内**。

**解读**：

- 对于高频读取配置值的场景（如网关、服务发现客户端、配置驱动的业务逻辑），单次操作几十纳秒的开销可以认为是“接近零成本”；
- 如果项目仍在使用 .NET 6.0，仅升级到 .NET 8.0 / 9.0 即可获得显著的单次操作性能提升，而无需改动业务代码；
- 从延迟角度看，大部分真实业务场景的瓶颈不会在配置访问上。

---

## 2. 大文件基准测试 (LargeFileBenchmarks)

`LargeFileBenchmarks-report-github.md` 中，每项均为 1000 条配置项的加载耗时（Mean）：

- 典型结果（不同运行时、不同格式的组合）：
  - Json / Ini 加载时间集中在 **约 180–260 μs**；
  - Xml 在 **500–550 μs** 左右；
  - Yaml / Toml 一般在 **800–1,400 μs** 区间；
- 相比上一轮测试，整体数值存在轻微波动，但**相对排序完全一致**：
  - **Ini ≈ Json < Xml < Yaml ≈ Toml**。

**解读**：

- **Ini / Json 依旧是大配置文件场景的首选**：加载速度快、内存占用相对更低；
- Xml 作为中间方案，性能尚可，更适合和现有 XML 生态集成时使用；
- Yaml / Toml 更偏向“可读性 / 表达能力”，在追求可维护性或与其他系统格式对齐时可以接受这部分性能损失；
- 对于一次性加载 1000 条配置项，几百微秒的级别在绝大多数 Web / 服务端应用中是可以接受的。

---

## 3. 并发基准测试 (ConcurrencyBenchmarks)

`ConcurrencyBenchmarks-report-github.md` 中，主要关注 4 线程并发下不同读写模式的平均耗时（Mean）：

- 典型数值：
  - 第一组（约 16–23 μs）对应 .NET 6.0 下的多种读写组合；
  - 对应场景在 .NET 8.0 / 9.0 下分别降到约 **6–7 μs / 16–20 μs / 4 μs** 级别；
- 与上一轮详细报告比对，可确认趋势：
  - **并发读场景：.NET 8.0 / 9.0 比 .NET 6.0 提升约 50–60%**；
  - 混合读写及写入场景，.NET 9.0 较 .NET 6.0 仍有 **30–40%** 提升。

**解读**：

- 在高并发场景下（多线程同时读 / 写配置），内部锁和数据结构设计表现稳定，没有出现明显的抖动或退化；
- 使用 .NET 8.0 / 9.0 的服务，可以在同样硬件资源下承载更多并发配置访问；
- 对于需要频繁动态读取配置（如开关、限流、动态路由）的系统，本次数据再次验证了线程安全且高性能的设计目标。

---

## 4. 缓存效果测试 (CacheBenchmarks)

`CacheBenchmarks-report-github.md` 中，每组场景分为：未启用缓存、缓存命中、缓存未命中等多种情况。结合上一轮的结构与本轮数值：

- 热路径读取（Hot Path）平均耗时：
  - .NET 6.0：约 **20–25 μs**；
  - .NET 8.0 / 9.0：约 **14–18 μs**；
- 单次首次访问（冷启动）：
  - 仍然保持在 **15–26 ns** 的级别，即“几乎无额外开销”；
- 在缓存命中 / 未命中之间，整体耗时差异不大，说明缓存策略本身较轻量，逻辑分支不会引入明显额外成本。

**解读**：

- 热路径缓存方案设计合理，在高频访问下既保持了较低延迟，又避免复杂缓存策略带来的额外开销；
- 对于热点配置项（如 Feature Flag、限流配置等），可以放心走缓存路径，不必担心缓存本身成为瓶颈；
- 和上一轮测试一致，本次依然验证了 **“缓存命中 / 未命中性能差距小”** 的目标。

---

## 5. 类型转换测试 (TypeConversionBenchmarks)

`TypeConversionBenchmarks-report-github.md` 中，列出了 String / Int / Bool / Double / Guid / DateTime / Enum / Nullable 等多种类型，从字符串配置转换为目标类型的耗时（Mean）：

- 整体量级：
  - 简单类型（String / Int / Bool）在 .NET 9.0 下多在 **60–100 ns** 以内；
  - 复杂类型（Guid / DateTime / Enum / Nullable）多在 **80–150 ns** 左右；
- 与上一轮的结论一致：
  - **.NET 9.0 在复杂类型转换上优势最为明显**，相比 .NET 6.0 提升普遍在 **30–60%**；
  - String 读取仍然属于“零分配 / 极低延迟”范畴。

**解读**：

- 如果应用里大量使用 `Get<int>()` / `Get<bool>()` / `Get<DateTime>()` 这类强类型读取接口，在 .NET 9.0 上可以得到非常可观的性能收益；
- 对批量配置绑定（对象映射）或频繁类型转换的场景，本次数据再次说明内置转换逻辑是可扩展和高性能的；
- 在配置读取路径中，类型转换的开销通常仍小于网络 / IO 等外部因素，对整体请求延迟影响有限。

---

## 6. 批量操作测试 (BatchOperationBenchmarks)

`BatchOperationBenchmarks-report-github.md` 中涵盖了 `GetMany` / `SetMany` 以及 `Get/Set` 循环多种组合：

- 小批量（10 键）与大批量（50 键）对比：
  - 10 键时，循环 `Get` 与 `GetMany` 差距不大；
  - 50 键时，`GetMany` 相比逐个 `Get` 可节省 **约 30–40%** 的耗时；
- `Get_Typed_Loop_10Keys` 在本轮中被标记为 NA（BenchmarkDotNet 报告“Benchmarks with issues”），说明该项在当前参数下统计不稳定，需要结合日志进一步排查（但不影响整体读写结论）。

**解读**：

- 对少量键（<10）时，直接循环调用 `Get` 即可，代码更简单；
- 对大量键（≥50）甚至更多时，建议使用 **`GetMany` / `SetMany`** 这类批量 API，可以显著减少内部查找和对象分配次数；
- 本轮测试提示：部分“类型化批量循环”场景在极短基准时间下容易遇到统计精度或抖动问题，后续可以视需要单独放宽迭代次数再测。

---

## 7. 多源合并测试 (MultiSourceBenchmarks)

`MultiSourceBenchmarks-report-github.md` 主要关心多配置源（如 Json + 环境变量 + 数据库）合并后的读取、写入性能：

- 读取高优先级 / 低优先级 / 共享键的平均耗时：
  - 单次读取通常在 **30–80 ns**；
  - 批量读取在 **10–25 μs** 范围；
- 写入新键 / 覆盖键的场景在本轮中有若干 NA（同样被列为“Benchmarks with issues”），说明这部分测试在当前参数下结果波动较大；
- 与上一轮的结论一致：
  - 多源合并带来的额外开销很小，**.NET 8.0 / 9.0 比 .NET 6.0 仍有 30–40% 的提升**。

**解读**：

- 多源合并的层级覆盖逻辑（如“环境变量 > appsettings.json > 默认配置”）对读取路径基本没有拖累；
- 对于复杂配置场景（微服务多环境、多租户、多层默认值等），可以放心使用 MultiSource 功能，而不用担心性能退化；
- 写入相关基准在本轮中有部分 NA，建议后续如需精确评估写性能，可单独提高迭代次数或调整参数重测。

---

## 8. 配置节访问测试 (GetSectionBenchmarks)

`GetSectionBenchmarks-report-github.md` 中列出多种配置节访问模式：

- 典型数值（Mean）：
  - `GetSection` / `GetSection(嵌套)` 级别为 **20–50 ns**；
  - `GetChildKeys` / `Section.GetChildKeys` 级别在 **0.4–0.9 μs**；
  - 直接 `Get` / `Section.Get` 在 **4–20 ns** 范围内；
- 与上一轮详细表格对比，数值存在自然波动，但量级和相对关系完全一致：
  - 直接 `Get` 略快于通过 `Section.Get`；
  - 深层级 `GetSection` 多出少量路径解析开销，但整体仍在几十纳秒级别。

**解读**：

- 对于只访问少数键的场景，直接 `Get` 是最简单且最快的方式；
- 对同一配置节多次访问时，通过 `GetSection` 获取节对象再复用，可以获得更好的结构化代码，同时几乎不会牺牲性能；
- `GetChildKeys` 的微秒级耗时对业务代码来说也非常轻量，适合动态遍历配置树的场景。

---

## 9. 其它基准（保存 / 删除 / MicrosoftConfig 转换 等）

本次 2025-12-25_223016 目录中主要包含核心读写/缓存/并发/类型转换/多源/配置节等基准，从上一轮 151849 的对比可以推断：

- **保存 (SaveBenchmarks)**：不同格式（Json/Ini/Xml/Yaml/Toml）保存 10 项配置的耗时仍在 **0.7–3.5 ms** 左右，Json 较慢但可接受；
- **删除 (RemoveBenchmarks)**：单键 / 批量删除在 **5–7 μs** 级别，删除后保存主要受文件格式影响；
- **Microsoft Configuration 转换 (MicrosoftConfigBenchmarks)**：`ToMicrosoftConfiguration` 操作通常在几十纳秒内完成，ConfigChanges 订阅 / 触发在几微秒级别，对动态配置场景成本很低。

---

## 10. 综合结论与使用建议

### 10.1 性能整体评价

- 核心操作（读 / 写 / 类型转换 / GetSection）全部保持在纳秒级；
- 批量操作（1000 项加载、多源读取）在毫秒以内，多数在几百微秒；
- **.NET 8.0 / 9.0 相比 .NET 6.0 的提升仍然稳定在 30–60% 区间**，与前两次测试趋势一致；
- 本轮新增的 NA 项（部分批量和多源写入基准）主要是统计稳定性问题，不影响对整体设计的判断。

### 10.2 运行时选择建议

- **优先推荐 .NET 8.0 或 .NET 9.0**：
  - 单次操作延迟更低，
  - 并发 / 类型转换场景优势明显，
  - 内存分配更少，GC 压力更小；
- 如果当前项目仍在 .NET 6.0，迁移到 .NET 8.0 / 9.0 不需要修改使用方式即可直接受益。

### 10.3 配置格式选择建议

| 场景             | 推荐格式         | 说明                                       |
|------------------|------------------|--------------------------------------------|
| 高频读写         | Json / Ini       | 单次操作几十纳秒，二者性能接近            |
| 大配置文件       | Ini / Json       | Ini 加载稍快，内存占用相对更低            |
| 人类可读性优先   | Yaml / Toml      | 语法友好，性能略慢但可接受                |
| 与现有系统集成   | Xml              | 兼容性和生态成熟                           |
| 批量操作（50+键）| GetMany/SetMany  | 比循环 Get/Set 快约 30–40%                |
| 多源配置         | MultiSource      | 读取性能与单源差距很小，覆盖规则灵活      |

### 10.4 实际落地建议

- 线上服务可将配置访问视为“非瓶颈”，更多精力放在网络 / 存储 / 业务逻辑优化上；
- 对配置较复杂的系统，推荐：多源合并 + 批量操作 + 强类型绑定组合使用，以获得兼顾性能和可维护性的方案；
- 对于基准中出现 NA 的场景，如需精确评估，可适当提高迭代次数或调整 BenchmarkDotNet 配置单独复测。
