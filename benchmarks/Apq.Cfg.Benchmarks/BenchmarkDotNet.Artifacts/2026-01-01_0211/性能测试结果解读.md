# Apq.Cfg 性能测试结果解读

## 测试环境

| 项目 | 详情 |
|------|------|
| **操作系统** | Windows 11 (10.0.26200.7462/25H2/2025Update) |
| **处理器** | AMD Ryzen 9 9950X3D 4.30GHz, 16核32线程 |
| **测试工具** | BenchmarkDotNet v0.15.8 |
| **SDK版本** | .NET SDK 10.0.101 |
| **测试运行时** | .NET 8.0.22, .NET 10.0.1 |
| **测试时间** | 2026-01-01 02:11 |

## 测试概览

本次性能测试覆盖以下 **18 个测试类别**：

1. BatchOperationBenchmarks - 批量操作性能
2. CacheBenchmarks - 缓存效果性能
3. ConcurrencyBenchmarks - 并发性能
4. CryptoBenchmarks - 加密解密性能
5. DependencyInjectionBenchmarks - 依赖注入性能
6. EncodingBenchmarks - 编码处理性能
7. GetSectionBenchmarks - 配置节获取性能
8. KeyPathBenchmarks - 键路径解析性能
9. LargeFileBenchmarks - 大文件处理性能
10. MicrosoftConfigBenchmarks - 与微软配置库对比
11. MultiSourceBenchmarks - 多源配置性能
12. ObjectBinderBenchmarks - 对象绑定性能
13. ReadWriteBenchmarks - 读写性能
14. RemoveBenchmarks - 删除操作性能
15. SaveBenchmarks - 保存操作性能
16. SourceGeneratorBenchmarks - 源生成器性能
17. TypeConversionBenchmarks - 类型转换性能
18. ZookeeperBenchmarks - Zookeeper集成性能

---

## 详细测试结果分析

### 1. 批量操作性能 (BatchOperationBenchmarks)

批量操作测试对比了 GetMany/SetMany 与单次循环操作的性能差异。

#### 批量读取性能对比

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| GetMany_10Keys | 348.2 ns | 341.4 ns | **.NET 10 快 2%** |
| Get_Loop_10Keys | 176.5 ns | 206.6 ns | .NET 8 快 15% |
| GetMany_50Keys | 1,659.8 ns | 1,547.2 ns | **.NET 10 快 7%** |
| Get_Loop_50Keys | 914.3 ns | 1,053.3 ns | .NET 8 快 13% |
| GetMany_100Keys | 3,339.0 ns | 3,351.0 ns | 持平 |
| Get_Loop_100Keys | 1,949.3 ns | 2,133.1 ns | .NET 8 快 9% |

#### 批量写入性能对比

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| SetMany_10Keys | 4,613.1 ns | 3,198.3 ns | **.NET 10 快 31%** |
| Set_Loop_10Keys | 3,363.3 ns | 2,018.2 ns | **.NET 10 快 40%** |
| SetMany_100Keys | 8,537.8 ns | 6,278.5 ns | **.NET 10 快 26%** |
| Set_Loop_100Keys | 6,423.0 ns | 4,423.1 ns | **.NET 10 快 31%** |

**关键发现**：
- 写入操作在 .NET 10 上有显著提升，比 .NET 8 快 26-40%
- 读取操作两个版本差异不大，.NET 8 在循环读取上略有优势
- 对于小批量操作（10个键），单次循环 Get 反而比 GetMany 更快

---

### 2. 缓存效果性能 (CacheBenchmarks)

测试热路径重复读取和缓存命中/未命中场景。

| 测试场景 | .NET 8.0 | .NET 10.0 | 性能变化 |
|----------|----------|-----------|----------|
| HotPath_SameKey_1000 | 13,359 ns | 13,687 ns | 持平 |
| HotPath_SameKey_10000 | 142,280 ns | 98,474 ns | **.NET 10 快 31%** |
| 单次缓存命中读取 | 15.70 ns | 18.54 ns | .NET 8 快 15% |
| 缓存未命中读取 | 1,565 ns | 1,984 ns | .NET 8 快 21% |
| 冷路径随机访问 | 90,061 ns | 94,106 ns | 持平 |

**关键发现**：
- 缓存命中时单次读取仅需 **~16-19 ns**，性能极佳
- 大量重复读取（10000次）在 .NET 10 上更快
- .NET 8 在单次缓存操作上略有优势

---

### 3. 并发性能 (ConcurrencyBenchmarks)

测试多线程并发读写场景（4线程）。

| 测试场景 | .NET 8.0 | .NET 10.0 | 性能变化 |
|----------|----------|-----------|----------|
| 并发读取同一键 | 6.630 us | 5.493 us | **.NET 10 快 17%** |
| 并发读取不同键 | 20.742 us | 15.977 us | **.NET 10 快 23%** |
| 并发写入不同键 | 4.037 us | 3.084 us | **.NET 10 快 24%** |
| 读写混合 | 4.377 us | 5.090 us | .NET 8 快 14% |
| 并发检查存在 | 21.069 us | 15.336 us | **.NET 10 快 27%** |
| 并发写入同一键 | 30.698 us | 31.462 us | 持平 |

**关键发现**：
- .NET 10 在大多数并发场景下表现更好
- 并发读取性能提升 17-23%
- 并发写入不同键性能提升 24%
- 读写混合场景 .NET 8 略有优势

---

### 4. 加密解密性能 (CryptoBenchmarks)

测试配置加密和解密操作的性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| AES加密 | 107,030 ns | 104,972 ns | 持平 |
| AES解密 | 103,478 ns | 99,046 ns | **.NET 10 快 4%** |
| Base64编码 | 663 ns | 684 ns | 持平 |
| Base64解码 | 1,993 ns | 1,840 ns | **.NET 10 快 8%** |
| SHA256哈希 | 854 ns | 845 ns | 持平 |
| 密钥派生 | 40,585 ns | 38,644 ns | **.NET 10 快 5%** |
| 空值检查 | 9.3 ns | 5.0 ns | **.NET 10 快 46%** |

**关键发现**：
- 加密解密性能在两个版本间差异较小
- 空值检查在 .NET 10 上显著提升 46%
- 整体加密操作稳定在 ~100 us 级别

---

### 5. 依赖注入性能 (DependencyInjectionBenchmarks)

测试与 DI 容器集成的性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 服务注册 | 138,925 ns | 141,614 ns | 持平 |
| 服务解析 | 7.89 ns | 7.65 ns | 持平 |
| 配置绑定 | 720 ns | 510 ns | **.NET 10 快 29%** |
| 选项模式 | 864 ns | 796 ns | **.NET 10 快 8%** |
| IConfiguration 获取 | 7.05 ns | 5.49 ns | **.NET 10 快 22%** |
| Scoped 解析 | 9.49 ns | 6.54 ns | **.NET 10 快 31%** |

**关键发现**：
- 服务解析在两个版本上都极快，仅需 **~7-8 ns**
- 配置绑定性能提升 29%
- IConfiguration 获取是最快的操作之一，仅需 **5.5 ns**（.NET 10）

---

### 6. 编码处理性能 (EncodingBenchmarks)

测试不同编码格式文件的处理性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| UTF-8 读取 | 35.46 us | 40.53 us | .NET 8 快 13% |
| UTF-8 BOM 读取 | 34.78 us | 36.57 us | 持平 |
| GB2312 读取 | 139.61 us | 152.55 us | .NET 8 快 8% |
| 大文件 UTF-8 | 35,376 us | 39,566 us | .NET 8 快 11% |
| 编码检测 | 1.45 us | 1.54 us | 持平 |

**关键发现**：
- 编码处理在 .NET 8 上略有优势
- 编码检测极快，仅需 **~1.5 us**
- GB2312 等非 UTF-8 编码处理较慢，建议使用 UTF-8

---

### 7. 配置节获取性能 (GetSectionBenchmarks)

测试不同深度配置节的获取性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 根级别获取 | 21.33 ns | 20.92 ns | 持平 |
| 1层嵌套 | 30.84 ns | 35.81 ns | .NET 8 快 14% |
| 深层嵌套(5层) | 1,020 ns | 1,015 ns | 持平 |
| 直接键访问 | 3.69 ns | 4.22 ns | .NET 8 快 13% |
| 子节点枚举 | 478 ns | 487 ns | 持平 |

**关键发现**：
- 直接键访问仅需 **~4 ns**，是最快的访问方式
- 深层嵌套访问约 **1 us**，性能稳定
- 建议使用扁平化键路径以获得最佳性能

---

### 8. 键路径解析性能 (KeyPathBenchmarks)

测试键路径解析和规范化性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 简单路径解析 | 13.68 ns | 11.90 ns | **.NET 10 快 13%** |
| 复杂路径解析 | 26.16 ns | 27.60 ns | 持平 |
| 路径规范化 | 51,499 ns | 51,180 ns | 持平 |
| 路径合并 | 56.70 ns | 50.53 ns | **.NET 10 快 11%** |
| 路径分割 | 4,151 ns | 3,013 ns | **.NET 10 快 27%** |

**关键发现**：
- 简单路径解析在 .NET 10 上更快
- 路径分割性能提升 27%
- 路径规范化是相对耗时的操作（~51 us），建议缓存结果

---

### 9. 大文件处理性能 (LargeFileBenchmarks)

测试大型配置文件的加载和处理性能。

| 文件格式 | .NET 8.0 | .NET 10.0 | 性能变化 |
|----------|----------|-----------|----------|
| JSON 加载 | 276.5 us | 266.5 us | **.NET 10 快 4%** |
| YAML 加载 | 218.5 us | 225.6 us | 持平 |
| XML 加载 | 661.1 us | 536.6 us | **.NET 10 快 19%** |
| TOML 加载 | 1,002.1 us | 831.3 us | **.NET 10 快 17%** |
| INI 加载 | 908.0 us | 983.6 us | .NET 8 快 8% |

**关键发现**：
- YAML 格式加载最快，约 **220 us**
- XML 和 TOML 在 .NET 10 上有显著提升
- JSON 性能稳定，约 **270 us**

---

### 10. 与微软配置库对比 (MicrosoftConfigBenchmarks)

对比 Apq.Cfg 与 Microsoft.Extensions.Configuration 的性能。

| 操作 | Apq.Cfg (.NET 10) | MS Config (.NET 10) | 对比 |
|------|-------------------|---------------------|------|
| 配置读取 | 58.29 ns | 80.86 ns | **Apq.Cfg 快 28%** |
| 配置写入 | 1,004 ns | N/A | - |
| 节获取 | 23.56 ns | 17.51 ns | MS Config 快 26% |
| 值绑定 | 5,867 ns | 2,151 ns | MS Config 快 63% |
| 空值检查 | 0.19 ns | 9.83 ns | **Apq.Cfg 快 98%** |

**关键发现**：
- Apq.Cfg 在配置读取和空值检查上更快
- MS Config 在值绑定上有优势
- Apq.Cfg 支持配置写入，MS Config 不支持

---

### 11. 多源配置性能 (MultiSourceBenchmarks)

测试多配置源合并和优先级处理性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 单源读取 | 44.18 ns | 43.15 ns | 持平 |
| 双源合并读取 | 50.25 ns | 48.44 ns | 持平 |
| 三源合并读取 | 39.82 ns | 35.60 ns | **.NET 10 快 11%** |
| 源优先级解析 | 9,297 ns | 9,380 ns | 持平 |
| 动态源切换 | 3,897 ns | 3,957 ns | 持平 |

**关键发现**：
- 多源合并性能稳定
- 三源合并读取在 .NET 10 上略有提升
- 动态源切换约 **4 us**

---

### 12. 对象绑定性能 (ObjectBinderBenchmarks)

测试配置到对象的绑定性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 简单对象绑定 | 335.1 ns | 358.2 ns | .NET 8 快 6% |
| 复杂对象绑定 | 1,810 ns | 1,764 ns | 持平 |
| 嵌套对象绑定 | 2,606 ns | 2,730 ns | 持平 |
| 集合绑定 | 4,849 ns | 4,214 ns | **.NET 10 快 13%** |
| 大对象绑定 | 455,682 ns | 443,488 ns | **.NET 10 快 3%** |

**关键发现**：
- 简单对象绑定仅需 **~350 ns**
- 集合绑定在 .NET 10 上有提升
- 大对象绑定耗时较长，建议分批处理

---

### 13. 读写性能 (ReadWriteBenchmarks)

测试基本读写操作性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 字符串读取 | 18.04 ns | 22.46 ns | .NET 8 快 20% |
| 字符串写入 | 26.54 ns | 33.73 ns | .NET 8 快 21% |
| 整数读取 | 18.67 ns | 22.64 ns | .NET 8 快 18% |
| 布尔读取 | 19.15 ns | 22.98 ns | .NET 8 快 17% |
| 空值读取 | 22.00 ns | 15.61 ns | **.NET 10 快 29%** |

**关键发现**：
- 基本读写操作都在纳秒级别完成
- .NET 8 在常规读写上略有优势
- 空值读取在 .NET 10 上更快

---

### 14. 删除操作性能 (RemoveBenchmarks)

测试配置项删除操作性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 单键删除 | 6.20 us | 5.30 us | **.NET 10 快 15%** |
| 批量删除(10) | 1.66 us | 1.53 us | **.NET 10 快 8%** |
| 节删除 | 1,300 us | 4,801 us | .NET 8 快 73% |
| 递归删除 | 2,193 us | 2,258 us | 持平 |

**关键发现**：
- 单键删除在 .NET 10 上最快，仅需 **5.3 us**
- 批量删除效率高于循环单次删除
- 节删除在 .NET 8 上更快

---

### 15. 保存操作性能 (SaveBenchmarks)

测试配置保存到文件的性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| JSON 保存 | 4,505 us | 4,173 us | **.NET 10 快 7%** |
| YAML 保存 | 4,470 us | 4,383 us | 持平 |
| 小文件保存 | 987 us | 867 us | **.NET 10 快 12%** |
| 增量保存 | 813 us | 896 us | .NET 8 快 9% |
| 异步保存 | 738 us | 869 us | .NET 8 快 15% |

**关键发现**：
- JSON 保存在 .NET 10 上略有提升
- 小文件保存性能稳定，约 **800-1000 us**
- 增量保存比全量保存更高效

---

### 16. 源生成器性能 (SourceGeneratorBenchmarks)

测试源生成器生成的强类型配置访问性能。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 生成类型读取 | 2,059 ns | 2,244 ns | .NET 8 快 8% |
| 反射读取 | 208,185 ns | 222,594 ns | .NET 8 快 6% |
| 生成类型写入 | 2,693 ns | 2,892 ns | .NET 8 快 7% |
| 直接属性访问 | 211 ns | 205 ns | 持平 |
| 嵌套属性访问 | 354 ns | 334 ns | **.NET 10 快 6%** |

**关键发现**：
- 源生成器比反射快 **100倍以上**
- 直接属性访问仅需 **~205-211 ns**
- 强烈推荐使用源生成器获得最佳性能

---

### 17. 类型转换性能 (TypeConversionBenchmarks)

测试配置值类型转换性能。

| 转换类型 | .NET 8.0 | .NET 10.0 | 性能变化 |
|----------|----------|-----------|----------|
| 字符串→整数 | 18.42 ns | 22.77 ns | .NET 8 快 19% |
| 字符串→浮点 | 22.72 ns | 32.17 ns | .NET 8 快 29% |
| 字符串→布尔 | 26.98 ns | 26.20 ns | 持平 |
| 字符串→日期 | 34.79 ns | 39.88 ns | .NET 8 快 13% |
| 字符串→枚举 | 58.43 ns | 51.33 ns | **.NET 10 快 12%** |
| 字符串→Guid | 68.60 ns | 61.95 ns | **.NET 10 快 10%** |
| 复杂类型转换 | 57,764 ns | 58,390 ns | 持平 |

**关键发现**：
- 基本类型转换都在纳秒级别
- 枚举和 Guid 转换在 .NET 10 上更快
- 复杂类型转换较慢，建议缓存转换结果

---

### 18. Zookeeper 集成性能 (ZookeeperBenchmarks)

测试 Zookeeper 配置源的模拟性能（无实际连接）。

| 操作 | .NET 8.0 | .NET 10.0 | 性能变化 |
|------|----------|-----------|----------|
| 连接检查 | 0.01 ns | 0.22 ns | - |
| 路径验证 | 0.03 ns | 0.02 ns | - |
| 节点存在检查 | 0.01 ns | 0.04 ns | - |

**关键发现**：
- 本地操作极快，均在亚纳秒级别
- 实际网络操作性能取决于 Zookeeper 服务器

---

## 性能优化建议

### 1. 运行时选择
- **.NET 10.0** 在写入操作、并发场景、大文件处理上有优势
- **.NET 8.0** 在基本读取、类型转换上略有优势
- 两个版本整体性能差异不大，可根据项目需求选择

### 2. 配置访问优化
- 使用**直接键访问**而非深层嵌套（4 ns vs 1,015 ns）
- 利用**缓存机制**，热路径读取仅需 16-19 ns
- 使用**源生成器**替代反射（100倍性能提升）
- **缓存键路径**：避免重复构建和解析键路径

### 3. 批量操作优化
- 小批量（<10个键）使用循环 Get 更快
- 大批量（>50个键）使用 GetMany/SetMany
- 批量写入后统一保存，避免频繁 IO

### 4. 文件格式选择
- **YAML**：加载最快，推荐用于大型配置
- **JSON**：性能均衡，生态支持好
- **XML**：功能丰富但性能较慢
- **TOML/INI**：简单场景可用，大文件性能较差

### 5. 并发场景优化
- 读操作天然线程安全，无需额外同步
- 写操作使用内置锁机制，性能稳定
- .NET 10 并发性能整体更优

---

## .NET 8.0 vs .NET 10.0 性能对比总结

| 场景 | .NET 8.0 优势 | .NET 10.0 优势 |
|------|---------------|----------------|
| 基本读取 | +15-20% | - |
| 批量写入 | - | +26-40% |
| 并发操作 | - | +17-27% |
| 大文件处理 | - | +4-19% |
| 类型转换 | +13-29% | - |
| 配置绑定 | - | +29% |
| 源生成器 | +6-8% | - |

---

## 总结

Apq.Cfg 在 .NET 8.0 和 .NET 10.0 上都展现出优异的性能表现：

| 指标 | .NET 8.0 | .NET 10.0 | 说明 |
|------|----------|-----------|------|
| 单次读取 | **16-18 ns** | **19-23 ns** | 缓存命中时 |
| 单次写入 | **27-28 ns** | **31-34 ns** | 内存操作 |
| 批量读取(100键) | **3.3 us** | **3.4 us** | GetMany |
| 批量写入(100键) | **8.5 us** | **6.3 us** | SetMany |
| 对象绑定 | **335 ns** | **358 ns** | 简单对象 |
| 文件保存 | **4.5 ms** | **4.2 ms** | JSON 格式 |

**核心优势**：
1. 纳秒级配置访问
2. 高效的缓存机制
3. 源生成器支持（100倍性能提升）
4. 线程安全设计
5. 多运行时优化

---

*报告生成时间：2026-01-01*
*测试框架：BenchmarkDotNet v0.15.8*
