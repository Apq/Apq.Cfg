# Apq.Cfg 配置加密脱敏设计方案

## 1. 设计目标

### 1.1 核心需求
- **加密**：敏感配置值（如数据库密码、API密钥）在存储时加密，读取时自动解密
- **脱敏**：日志输出、调试显示时自动隐藏敏感信息
- **零侵入**：不修改现有配置文件格式，通过约定标记敏感配置
- **可扩展**：支持多种加密算法，用户可自定义

### 1.2 架构约束
- **Apq.Cfg 核心库不依赖任何加密扩展包**
- 加密/脱敏功能通过独立扩展包提供
- 使用接口抽象和依赖注入实现解耦

## 2. 架构设计

### 2.1 依赖关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户应用程序                              │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ Apq.Cfg.Crypto  │  │ Apq.Cfg.Crypto  │  │ Apq.Cfg.Crypto  │  │
│  │    .AesGcm      │  │    .DataProt    │  │    .Custom      │  │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘  │
│           │                    │                    │           │
│           └────────────────────┼────────────────────┘           │
│                                │                                │
│                    ┌───────────▼───────────┐                    │
│                    │   Apq.Cfg.Crypto      │                    │
│                    │   (核心加密抽象)       │                    │
│                    └───────────┬───────────┘                    │
│                                │                                │
│                    ┌───────────▼───────────┐                    │
│                    │      Apq.Cfg          │                    │
│                    │   (核心配置库)         │                    │
│                    │   定义接口抽象         │                    │
│                    └───────────────────────┘                    │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 核心接口设计（位于 Apq.Cfg）

```csharp
// Apq.Cfg/Security/IValueTransformer.cs
namespace Apq.Cfg.Security;

/// <summary>
/// 配置值转换器接口，用于加密/解密、脱敏等场景
/// </summary>
public interface IValueTransformer
{
    /// <summary>
    /// 转换器名称，用于标识
    /// </summary>
    string Name { get; }
    
    /// <summary>
    /// 优先级，数值越大优先级越高
    /// </summary>
    int Priority { get; }
    
    /// <summary>
    /// 判断是否应该处理该键
    /// </summary>
    bool ShouldTransform(string key, string? value);
    
    /// <summary>
    /// 读取时转换（如解密）
    /// </summary>
    string? TransformOnRead(string key, string? value);
    
    /// <summary>
    /// 写入时转换（如加密）
    /// </summary>
    string? TransformOnWrite(string key, string? value);
}

// Apq.Cfg/Security/IValueMasker.cs
namespace Apq.Cfg.Security;

/// <summary>
/// 配置值脱敏器接口，用于日志输出等场景
/// </summary>
public interface IValueMasker
{
    /// <summary>
    /// 判断是否应该脱敏该键
    /// </summary>
    bool ShouldMask(string key);
    
    /// <summary>
    /// 脱敏处理
    /// </summary>
    string Mask(string key, string? value);
}

// Apq.Cfg/Security/ValueTransformerOptions.cs
namespace Apq.Cfg.Security;

/// <summary>
/// 值转换器配置选项
/// </summary>
public class ValueTransformerOptions
{
    /// <summary>
    /// 是否启用值转换，默认 true
    /// </summary>
    public bool Enabled { get; set; } = true;
    
    /// <summary>
    /// 敏感键模式列表（支持通配符）
    /// </summary>
    public List<string> SensitiveKeyPatterns { get; set; } = new()
    {
        "*Password*",
        "*Secret*",
        "*ApiKey*",
        "*ConnectionString*",
        "*Credential*",
        "*Token*"
    };
    
    /// <summary>
    /// 加密值前缀标记（使用花括号避免与配置节分隔符 : 混淆）
    /// </summary>
    public string EncryptedPrefix { get; set; } = "{ENC}";
}
```

### 2.3 CfgBuilder 扩展点

```csharp
// Apq.Cfg/CfgBuilder.cs 新增
public sealed class CfgBuilder
{
    private readonly List<IValueTransformer> _transformers = new();
    private readonly List<IValueMasker> _maskers = new();
    private ValueTransformerOptions _transformerOptions = new();
    
    // ... 现有代码 ...
    
    /// <summary>
    /// 添加值转换器（供扩展包使用）
    /// </summary>
    public CfgBuilder AddValueTransformer(IValueTransformer transformer)
    {
        _transformers.Add(transformer);
        return this;
    }
    
    /// <summary>
    /// 添加值脱敏器（供扩展包使用）
    /// </summary>
    public CfgBuilder AddValueMasker(IValueMasker masker)
    {
        _maskers.Add(masker);
        return this;
    }
    
    /// <summary>
    /// 配置值转换选项
    /// </summary>
    public CfgBuilder ConfigureValueTransformer(Action<ValueTransformerOptions> configure)
    {
        configure(_transformerOptions);
        return this;
    }
    
    public ICfgRoot Build()
    {
        var transformerChain = _transformers.Count > 0 
            ? new ValueTransformerChain(_transformers, _transformerOptions)
            : null;
        var maskerChain = _maskers.Count > 0
            ? new ValueMaskerChain(_maskers)
            : null;
            
        return new MergedCfgRoot(_sources, transformerChain, maskerChain);
    }
}
```

### 2.4 内部实现（位于 Apq.Cfg）

```csharp
// Apq.Cfg/Internal/ValueTransformerChain.cs
namespace Apq.Cfg.Internal;

internal sealed class ValueTransformerChain
{
    private readonly IValueTransformer[] _transformers;
    private readonly ValueTransformerOptions _options;
    
    public ValueTransformerChain(
        IEnumerable<IValueTransformer> transformers,
        ValueTransformerOptions options)
    {
        _transformers = transformers.OrderByDescending(t => t.Priority).ToArray();
        _options = options;
    }
    
    public string? TransformOnRead(string key, string? value)
    {
        if (!_options.Enabled || value == null)
            return value;
            
        foreach (var transformer in _transformers)
        {
            if (transformer.ShouldTransform(key, value))
            {
                value = transformer.TransformOnRead(key, value);
            }
        }
        return value;
    }
    
    public string? TransformOnWrite(string key, string? value)
    {
        if (!_options.Enabled || value == null)
            return value;
            
        foreach (var transformer in _transformers)
        {
            if (transformer.ShouldTransform(key, value))
            {
                value = transformer.TransformOnWrite(key, value);
            }
        }
        return value;
    }
}

// Apq.Cfg/Internal/ValueMaskerChain.cs
namespace Apq.Cfg.Internal;

internal sealed class ValueMaskerChain
{
    private readonly IValueMasker[] _maskers;
    
    public ValueMaskerChain(IEnumerable<IValueMasker> maskers)
    {
        _maskers = maskers.ToArray();
    }
    
    public string Mask(string key, string? value)
    {
        if (value == null)
            return "[null]";
            
        foreach (var masker in _maskers)
        {
            if (masker.ShouldMask(key))
            {
                return masker.Mask(key, value);
            }
        }
        return value;
    }
}
```

## 3. 扩展包设计

### 3.1 Apq.Cfg.Crypto（加密核心包）

```csharp
// Apq.Cfg.Crypto/ICryptoProvider.cs
namespace Apq.Cfg.Crypto;

/// <summary>
/// 加密提供者接口
/// </summary>
public interface ICryptoProvider
{
    /// <summary>
    /// 加密
    /// </summary>
    string Encrypt(string plainText);
    
    /// <summary>
    /// 解密
    /// </summary>
    string Decrypt(string cipherText);
}

// Apq.Cfg.Crypto/EncryptionTransformer.cs
namespace Apq.Cfg.Crypto;

/// <summary>
/// 加密值转换器
/// </summary>
public class EncryptionTransformer : IValueTransformer
{
    private readonly ICryptoProvider _provider;
    private readonly EncryptionOptions _options;
    
    public string Name => "Encryption";
    public int Priority => 100;
    
    public EncryptionTransformer(ICryptoProvider provider, EncryptionOptions? options = null)
    {
        _provider = provider;
        _options = options ?? new EncryptionOptions();
    }
    
    public bool ShouldTransform(string key, string? value)
    {
        // 读取时：检查是否有加密前缀
        if (value?.StartsWith(_options.EncryptedPrefix) == true)
            return true;
            
        // 写入时：检查是否匹配敏感键模式
        return _options.SensitiveKeyPatterns.Any(pattern => 
            MatchPattern(key, pattern));
    }
    
    public string? TransformOnRead(string key, string? value)
    {
        if (value == null)
            return null;
            
        if (!value.StartsWith(_options.EncryptedPrefix))
            return value;
            
        var cipherText = value.Substring(_options.EncryptedPrefix.Length);
        return _provider.Decrypt(cipherText);
    }
    
    public string? TransformOnWrite(string key, string? value)
    {
        if (value == null)
            return null;
            
        // 已加密的不重复加密
        if (value.StartsWith(_options.EncryptedPrefix))
            return value;
            
        // 检查是否需要加密
        if (!_options.SensitiveKeyPatterns.Any(p => MatchPattern(key, p)))
            return value;
            
        var cipherText = _provider.Encrypt(value);
        return _options.EncryptedPrefix + cipherText;
    }
    
    private static bool MatchPattern(string key, string pattern)
    {
        // 简单通配符匹配实现
        var regex = "^" + Regex.Escape(pattern)
            .Replace("\\*", ".*")
            .Replace("\\?", ".") + "$";
        return Regex.IsMatch(key, regex, RegexOptions.IgnoreCase);
    }
}

// Apq.Cfg.Crypto/EncryptionOptions.cs
namespace Apq.Cfg.Crypto;

public class EncryptionOptions
{
    /// <summary>
    /// 敏感键模式（支持通配符 * 和 ?）
    /// </summary>
    public List<string> SensitiveKeyPatterns { get; set; } = new()
    {
        "*Password*",
        "*Secret*",
        "*ApiKey*",
        "*ConnectionString*",
        "*Credential*",
        "*Token*"
    };
    
    /// <summary>
    /// 加密值前缀标记（使用花括号避免与配置节分隔符 : 混淆）
    /// </summary>
    public string EncryptedPrefix { get; set; } = "{ENC}";
    
    /// <summary>
    /// 是否在写入时自动加密匹配的敏感键
    /// </summary>
    public bool AutoEncryptOnWrite { get; set; } = true;
}

// Apq.Cfg.Crypto/SensitiveMasker.cs
namespace Apq.Cfg.Crypto;

/// <summary>
/// 敏感值脱敏器
/// </summary>
public class SensitiveMasker : IValueMasker
{
    private readonly MaskingOptions _options;
    
    public SensitiveMasker(MaskingOptions? options = null)
    {
        _options = options ?? new MaskingOptions();
    }
    
    public bool ShouldMask(string key)
    {
        return _options.SensitiveKeyPatterns.Any(pattern => 
            MatchPattern(key, pattern));
    }
    
    public string Mask(string key, string? value)
    {
        if (value == null)
            return _options.NullPlaceholder;
            
        if (value.Length <= _options.VisibleChars * 2)
            return _options.MaskString;
            
        return value.Substring(0, _options.VisibleChars) 
            + _options.MaskString 
            + value.Substring(value.Length - _options.VisibleChars);
    }
    
    private static bool MatchPattern(string key, string pattern)
    {
        var regex = "^" + Regex.Escape(pattern)
            .Replace("\\*", ".*")
            .Replace("\\?", ".") + "$";
        return Regex.IsMatch(key, regex, RegexOptions.IgnoreCase);
    }
}

// Apq.Cfg.Crypto/MaskingOptions.cs
namespace Apq.Cfg.Crypto;

public class MaskingOptions
{
    /// <summary>
    /// 敏感键模式
    /// </summary>
    public List<string> SensitiveKeyPatterns { get; set; } = new()
    {
        "*Password*",
        "*Secret*",
        "*ApiKey*",
        "*ConnectionString*",
        "*Credential*",
        "*Token*"
    };
    
    /// <summary>
    /// 脱敏字符串
    /// </summary>
    public string MaskString { get; set; } = "***";
    
    /// <summary>
    /// 保留可见字符数
    /// </summary>
    public int VisibleChars { get; set; } = 3;
    
    /// <summary>
    /// null 值占位符
    /// </summary>
    public string NullPlaceholder { get; set; } = "[null]";
}

// Apq.Cfg.Crypto/CfgBuilderExtensions.cs
namespace Apq.Cfg.Crypto;

public static class CfgBuilderExtensions
{
    /// <summary>
    /// 添加加密支持
    /// </summary>
    public static CfgBuilder AddEncryption(
        this CfgBuilder builder,
        ICryptoProvider provider,
        Action<EncryptionOptions>? configure = null)
    {
        var options = new EncryptionOptions();
        configure?.Invoke(options);
        
        builder.AddValueTransformer(new EncryptionTransformer(provider, options));
        return builder;
    }
    
    /// <summary>
    /// 添加敏感值脱敏
    /// </summary>
    public static CfgBuilder AddSensitiveMasking(
        this CfgBuilder builder,
        Action<MaskingOptions>? configure = null)
    {
        var options = new MaskingOptions();
        configure?.Invoke(options);
        
        builder.AddValueMasker(new SensitiveMasker(options));
        return builder;
    }
}
```

### 3.2 Apq.Cfg.Crypto.AesGcm（AES-GCM 加密实现）

```csharp
// Apq.Cfg.Crypto.AesGcm/AesGcmCryptoProvider.cs
namespace Apq.Cfg.Crypto.AesGcm;

/// <summary>
/// AES-GCM 加密提供者
/// </summary>
public class AesGcmCryptoProvider : ICryptoProvider, IDisposable
{
    private readonly byte[] _key;
    
    public AesGcmCryptoProvider(byte[] key)
    {
        if (key.Length != 16 && key.Length != 24 && key.Length != 32)
            throw new ArgumentException("Key must be 128, 192, or 256 bits");
        _key = key;
    }
    
    public AesGcmCryptoProvider(string base64Key)
        : this(Convert.FromBase64String(base64Key))
    {
    }
    
    public string Encrypt(string plainText)
    {
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var nonce = new byte[12];
        RandomNumberGenerator.Fill(nonce);
        
        var cipherBytes = new byte[plainBytes.Length];
        var tag = new byte[16];
        
        using var aes = new System.Security.Cryptography.AesGcm(_key, 16);
        aes.Encrypt(nonce, plainBytes, cipherBytes, tag);
        
        // 格式: nonce(12) + tag(16) + cipher
        var result = new byte[nonce.Length + tag.Length + cipherBytes.Length];
        Buffer.BlockCopy(nonce, 0, result, 0, nonce.Length);
        Buffer.BlockCopy(tag, 0, result, nonce.Length, tag.Length);
        Buffer.BlockCopy(cipherBytes, 0, result, nonce.Length + tag.Length, cipherBytes.Length);
        
        return Convert.ToBase64String(result);
    }
    
    public string Decrypt(string cipherText)
    {
        var data = Convert.FromBase64String(cipherText);
        
        var nonce = new byte[12];
        var tag = new byte[16];
        var cipherBytes = new byte[data.Length - 28];
        
        Buffer.BlockCopy(data, 0, nonce, 0, 12);
        Buffer.BlockCopy(data, 12, tag, 0, 16);
        Buffer.BlockCopy(data, 28, cipherBytes, 0, cipherBytes.Length);
        
        var plainBytes = new byte[cipherBytes.Length];
        
        using var aes = new System.Security.Cryptography.AesGcm(_key, 16);
        aes.Decrypt(nonce, cipherBytes, tag, plainBytes);
        
        return Encoding.UTF8.GetString(plainBytes);
    }
    
    public void Dispose()
    {
        Array.Clear(_key, 0, _key.Length);
    }
}

// Apq.Cfg.Crypto.AesGcm/CfgBuilderExtensions.cs
namespace Apq.Cfg.Crypto.AesGcm;

public static class CfgBuilderExtensions
{
    /// <summary>
    /// 添加 AES-GCM 加密支持
    /// </summary>
    public static CfgBuilder AddAesGcmEncryption(
        this CfgBuilder builder,
        string base64Key,
        Action<EncryptionOptions>? configure = null)
    {
        var provider = new AesGcmCryptoProvider(base64Key);
        return builder.AddEncryption(provider, configure);
    }
    
    /// <summary>
    /// 添加 AES-GCM 加密支持（从环境变量读取密钥）
    /// </summary>
    public static CfgBuilder AddAesGcmEncryptionFromEnv(
        this CfgBuilder builder,
        string envVarName = "APQ_CFG_ENCRYPTION_KEY",
        Action<EncryptionOptions>? configure = null)
    {
        var key = Environment.GetEnvironmentVariable(envVarName)
            ?? throw new InvalidOperationException($"环境变量 {envVarName} 未设置");
        return builder.AddAesGcmEncryption(key, configure);
    }
}
```

### 3.3 Apq.Cfg.Crypto.DataProtection（Windows DPAPI 实现）

```csharp
// Apq.Cfg.Crypto.DataProtection/DataProtectionCryptoProvider.cs
namespace Apq.Cfg.Crypto.DataProtection;

/// <summary>
/// 使用 ASP.NET Core Data Protection 的加密提供者
/// </summary>
public class DataProtectionCryptoProvider : ICryptoProvider
{
    private readonly IDataProtector _protector;
    
    public DataProtectionCryptoProvider(IDataProtectionProvider provider, string purpose = "Apq.Cfg")
    {
        _protector = provider.CreateProtector(purpose);
    }
    
    public string Encrypt(string plainText)
    {
        return _protector.Protect(plainText);
    }
    
    public string Decrypt(string cipherText)
    {
        return _protector.Unprotect(cipherText);
    }
}

// Apq.Cfg.Crypto.DataProtection/CfgBuilderExtensions.cs
namespace Apq.Cfg.Crypto.DataProtection;

public static class CfgBuilderExtensions
{
    /// <summary>
    /// 添加 Data Protection 加密支持
    /// </summary>
    public static CfgBuilder AddDataProtectionEncryption(
        this CfgBuilder builder,
        IDataProtectionProvider provider,
        string purpose = "Apq.Cfg",
        Action<EncryptionOptions>? configure = null)
    {
        var cryptoProvider = new DataProtectionCryptoProvider(provider, purpose);
        return builder.AddEncryption(cryptoProvider, configure);
    }
}
```

## 4. ICfgRoot 扩展方法

```csharp
// Apq.Cfg/CfgRootExtensions.cs 新增
namespace Apq.Cfg;

public static partial class CfgRootExtensions
{
    /// <summary>
    /// 获取脱敏后的配置值（用于日志输出）
    /// </summary>
    public static string GetMasked(this ICfgRoot cfg, string key)
    {
        if (cfg is MergedCfgRoot merged)
        {
            return merged.GetMasked(key);
        }
        return cfg.Get(key) ?? "[null]";
    }
    
    /// <summary>
    /// 获取所有配置的脱敏快照（用于调试）
    /// </summary>
    public static IReadOnlyDictionary<string, string> GetMaskedSnapshot(this ICfgRoot cfg)
    {
        if (cfg is MergedCfgRoot merged)
        {
            return merged.GetMaskedSnapshot();
        }
        
        var result = new Dictionary<string, string>();
        foreach (var key in cfg.GetChildKeys())
        {
            result[key] = cfg.Get(key) ?? "[null]";
        }
        return result;
    }
}
```

## 5. 使用示例

### 5.1 基本使用

```csharp
// 配置文件 appsettings.json
{
    "Database": {
        "ConnectionString": "{ENC}base64encodedciphertext...",
        "Password": "{ENC}base64encodedciphertext..."
    },
    "Api": {
        "Key": "{ENC}base64encodedciphertext..."
    }
}

// 程序代码
var cfg = new CfgBuilder()
    .AddJson("appsettings.json", level: 0, writeable: false)
    .AddAesGcmEncryptionFromEnv()  // 从环境变量读取密钥
    .AddSensitiveMasking()          // 添加脱敏支持
    .Build();

// 读取时自动解密
var connectionString = cfg.Get("Database:ConnectionString");

// 日志输出时自动脱敏
logger.LogInformation("连接字符串: {ConnectionString}", cfg.GetMasked("Database:ConnectionString"));
// 输出: 连接字符串: Ser***ion
```

### 5.2 写入加密

```csharp
var cfg = new CfgBuilder()
    .AddJson("appsettings.json", level: 0, writeable: true, isPrimaryWriter: true)
    .AddAesGcmEncryption("base64key...")
    .Build();

// 写入时自动加密（如果键匹配敏感模式）
cfg.Set("Database:Password", "mySecretPassword");
await cfg.SaveAsync();

// 文件中保存的是: "Database:Password": "{ENC}base64ciphertext..."
```

### 5.3 自定义加密提供者

```csharp
public class VaultCryptoProvider : ICryptoProvider
{
    private readonly IVaultClient _vault;
    
    public VaultCryptoProvider(IVaultClient vault)
    {
        _vault = vault;
    }
    
    public string Encrypt(string plainText)
    {
        return _vault.Transit.Encrypt("my-key", plainText).Result;
    }
    
    public string Decrypt(string cipherText)
    {
        return _vault.Transit.Decrypt("my-key", cipherText).Result;
    }
}

// 使用
var cfg = new CfgBuilder()
    .AddJson("appsettings.json", level: 0, writeable: false)
    .AddEncryption(new VaultCryptoProvider(vaultClient))
    .Build();
```

### 5.4 自定义前缀

```csharp
// 如果不喜欢默认的 {ENC} 前缀，可以自定义
var cfg = new CfgBuilder()
    .AddJson("appsettings.json", level: 0, writeable: false)
    .AddAesGcmEncryption("base64key...", options =>
    {
        options.EncryptedPrefix = "[ENCRYPTED]";  // 自定义前缀
        // 或者使用其他格式
        // options.EncryptedPrefix = "$$ENC$$";
        // options.EncryptedPrefix = "~enc~";
    })
    .Build();
```

### 5.5 与 DI 集成

```csharp
// Program.cs
services.AddApqCfg(builder => builder
    .AddJson("appsettings.json", level: 0, writeable: false)
    .AddAesGcmEncryptionFromEnv()
    .AddSensitiveMasking());

// 或者使用 Data Protection
services.AddDataProtection();
services.AddApqCfg((builder, sp) => builder
    .AddJson("appsettings.json", level: 0, writeable: false)
    .AddDataProtectionEncryption(sp.GetRequiredService<IDataProtectionProvider>())
    .AddSensitiveMasking());
```

## 6. 命令行工具

### 6.1 加密工具

```bash
# 安装工具
dotnet tool install -g Apq.Cfg.Crypto.Tool

# 生成密钥
apq-cfg-crypto generate-key --algorithm aes-gcm --bits 256

# 加密值
apq-cfg-crypto encrypt --key "base64key..." --value "mySecret"
# 输出: {ENC}base64ciphertext...

# 解密值
apq-cfg-crypto decrypt --key "base64key..." --value "{ENC}base64cipher..."

# 使用自定义前缀
apq-cfg-crypto encrypt --key "base64key..." --value "mySecret" --prefix "[ENCRYPTED]"

# 批量加密配置文件中的敏感值
apq-cfg-crypto encrypt-file --key "base64key..." --file appsettings.json --patterns "*Password*,*Secret*"
```

## 7. 安全最佳实践

### 7.1 密钥管理
- **不要**将加密密钥存储在配置文件中
- 使用环境变量、密钥管理服务（如 Azure Key Vault、HashiCorp Vault）
- 定期轮换密钥

### 7.2 加密算法选择
- 推荐使用 AES-GCM（认证加密）
- 避免使用 ECB 模式
- 使用足够长的密钥（256 位）

### 7.3 脱敏策略
- 日志中始终使用脱敏值
- 调试输出使用脱敏快照
- 异常消息中不包含敏感值

## 8. 包结构

```
Apq.Cfg                          # 核心库（定义接口）
├── Security/
│   ├── IValueTransformer.cs
│   ├── IValueMasker.cs
│   └── ValueTransformerOptions.cs
└── Internal/
    ├── ValueTransformerChain.cs
    └── ValueMaskerChain.cs

Apq.Cfg.Crypto                   # 加密核心包
├── ICryptoProvider.cs
├── EncryptionTransformer.cs
├── EncryptionOptions.cs
├── SensitiveMasker.cs
├── MaskingOptions.cs
└── CfgBuilderExtensions.cs

Apq.Cfg.Crypto.AesGcm            # AES-GCM 实现
├── AesGcmCryptoProvider.cs
└── CfgBuilderExtensions.cs

Apq.Cfg.Crypto.DataProtection    # Data Protection 实现
├── DataProtectionCryptoProvider.cs
└── CfgBuilderExtensions.cs

Apq.Cfg.Crypto.Tool              # 命令行工具
└── Program.cs
```

## 9. 依赖关系总结

| 包 | 依赖 |
|---|---|
| Apq.Cfg | 无加密依赖 |
| Apq.Cfg.Crypto | Apq.Cfg |
| Apq.Cfg.Crypto.AesGcm | Apq.Cfg.Crypto |
| Apq.Cfg.Crypto.DataProtection | Apq.Cfg.Crypto, Microsoft.AspNetCore.DataProtection |
| Apq.Cfg.Crypto.Tool | Apq.Cfg.Crypto.AesGcm |

**关键点**：Apq.Cfg 核心库只定义接口（`IValueTransformer`、`IValueMasker`），不包含任何加密实现，因此不依赖任何加密扩展包。加密功能完全由扩展包提供，用户按需引用。

## 10. 前缀格式选择说明

### 10.1 为什么不使用 `ENC:` 前缀

配置节的键使用 `:` 作为分隔符（如 `Database:ConnectionString`），如果加密前缀也使用 `:` 会造成混淆：

```json
// 容易混淆的格式
"Password": "ENC:base64cipher..."  // ENC 看起来像是配置节名

// 推荐的格式
"Password": "{ENC}base64cipher..."  // 花括号明确标识这是前缀
```

### 10.2 推荐的前缀格式

| 前缀 | 说明 |
|---|---|
| `{ENC}` | 默认推荐，使用花括号包裹 |
| `[ENCRYPTED]` | 方括号格式，更明确 |
| `$$ENC$$` | 双美元符号，不易与其他格式冲突 |
| `~enc~` | 波浪号格式，简洁 |

### 10.3 自定义前缀

用户可以根据项目规范自定义前缀：

```csharp
.AddAesGcmEncryption("key...", options =>
{
    options.EncryptedPrefix = "YOUR_PREFIX_HERE";
})
```
