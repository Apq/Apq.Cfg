# Apq.Cfg 配置加密/脱敏功能设计方案

**创建日期**：2025-12-28

---

## 一、需求分析

### 1.1 背景

在实际应用中，配置文件经常包含敏感信息，如：
- 数据库连接字符串（包含密码）
- API 密钥和访问令牌
- 加密密钥和证书
- 第三方服务凭证

这些敏感配置如果以明文存储，存在以下安全风险：
1. 配置文件泄露导致凭证暴露
2. 日志输出时意外打印敏感信息
3. 配置中心传输过程中被截获
4. 开发/测试环境配置误用到生产环境

### 1.2 目标

1. **配置加密**：敏感配置值在存储时加密，读取时自动解密
2. **配置脱敏**：日志输出、调试显示时自动隐藏敏感信息
3. **密钥管理**：支持多种密钥来源（环境变量、文件、Vault 等）
4. **向后兼容**：不影响现有 API，可选启用

---

## 二、设计方案

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         应用层                                   │
│  cfg.Get("Database:Password")  →  返回解密后的明文              │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Apq.Cfg.Crypto                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │ ICryptoProvider │  │ IMaskingProvider │  │ IKeyProvider      │  │
│  │ - Encrypt()    │  │ - Mask()         │  │ - GetKey()        │  │
│  │ - Decrypt()    │  │ - IsSensitive()  │  │ - RotateKey()     │  │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      配置源层                                    │
│  JSON / YAML / Consul / Vault / ...                             │
│  存储格式: "ENC(AES256:base64密文)" 或 明文                      │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 核心接口设计

#### 2.2.1 加密提供者接口

```csharp
namespace Apq.Cfg.Crypto;

/// <summary>
/// 加密提供者接口
/// </summary>
public interface ICryptoProvider
{
    /// <summary>
    /// 加密算法名称（如 "AES256"、"RSA"）
    /// </summary>
    string Algorithm { get; }

    /// <summary>
    /// 加密配置值
    /// </summary>
    /// <param name="plainText">明文</param>
    /// <param name="key">加密密钥</param>
    /// <returns>密文（Base64 编码）</returns>
    string Encrypt(string plainText, byte[] key);

    /// <summary>
    /// 解密配置值
    /// </summary>
    /// <param name="cipherText">密文（Base64 编码）</param>
    /// <param name="key">解密密钥</param>
    /// <returns>明文</returns>
    string Decrypt(string cipherText, byte[] key);
}
```

#### 2.2.2 密钥提供者接口

```csharp
namespace Apq.Cfg.Crypto;

/// <summary>
/// 密钥提供者接口
/// </summary>
public interface IKeyProvider
{
    /// <summary>
    /// 获取当前加密密钥
    /// </summary>
    byte[] GetKey();

    /// <summary>
    /// 获取指定版本的密钥（用于密钥轮换）
    /// </summary>
    /// <param name="version">密钥版本</param>
    byte[]? GetKey(int version);

    /// <summary>
    /// 当前密钥版本
    /// </summary>
    int CurrentVersion { get; }
}
```

#### 2.2.3 脱敏提供者接口

```csharp
namespace Apq.Cfg.Crypto;

/// <summary>
/// 脱敏提供者接口
/// </summary>
public interface IMaskingProvider
{
    /// <summary>
    /// 判断配置键是否为敏感配置
    /// </summary>
    /// <param name="key">配置键</param>
    bool IsSensitive(string key);

    /// <summary>
    /// 对敏感值进行脱敏处理
    /// </summary>
    /// <param name="key">配置键</param>
    /// <param name="value">原始值</param>
    /// <returns>脱敏后的值</returns>
    string Mask(string key, string? value);
}
```

### 2.3 加密值格式

采用自描述格式，便于识别和解析：

```
ENC(算法:版本:密文)
```

示例：
```json
{
  "Database": {
    "Host": "localhost",
    "Port": 5432,
    "Password": "ENC(AES256:1:U2FsdGVkX1+abc123...)"
  },
  "ApiKey": "ENC(AES256:1:U2FsdGVkX1+xyz789...)"
}
```

格式说明：
- `ENC(...)` - 标识这是一个加密值
- `AES256` - 加密算法
- `1` - 密钥版本（支持密钥轮换）
- `U2FsdGVkX1+...` - Base64 编码的密文

### 2.4 内置实现

#### 2.4.1 AES-256-GCM 加密提供者

```csharp
namespace Apq.Cfg.Crypto;

/// <summary>
/// AES-256-GCM 加密提供者（推荐，提供认证加密）
/// </summary>
public sealed class Aes256GcmCryptoProvider : ICryptoProvider
{
    public string Algorithm => "AES256GCM";

    public string Encrypt(string plainText, byte[] key)
    {
        // 使用 AES-256-GCM 加密
        // 格式: IV(12字节) + Tag(16字节) + 密文
        using var aes = new AesGcm(key);
        var nonce = new byte[AesGcm.NonceByteSizes.MaxSize]; // 12 bytes
        RandomNumberGenerator.Fill(nonce);
        
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var cipherBytes = new byte[plainBytes.Length];
        var tag = new byte[AesGcm.TagByteSizes.MaxSize]; // 16 bytes
        
        aes.Encrypt(nonce, plainBytes, cipherBytes, tag);
        
        // 组合: nonce + tag + cipher
        var result = new byte[nonce.Length + tag.Length + cipherBytes.Length];
        Buffer.BlockCopy(nonce, 0, result, 0, nonce.Length);
        Buffer.BlockCopy(tag, 0, result, nonce.Length, tag.Length);
        Buffer.BlockCopy(cipherBytes, 0, result, nonce.Length + tag.Length, cipherBytes.Length);
        
        return Convert.ToBase64String(result);
    }

    public string Decrypt(string cipherText, byte[] key)
    {
        var data = Convert.FromBase64String(cipherText);
        
        var nonce = new byte[AesGcm.NonceByteSizes.MaxSize];
        var tag = new byte[AesGcm.TagByteSizes.MaxSize];
        var cipherBytes = new byte[data.Length - nonce.Length - tag.Length];
        
        Buffer.BlockCopy(data, 0, nonce, 0, nonce.Length);
        Buffer.BlockCopy(data, nonce.Length, tag, 0, tag.Length);
        Buffer.BlockCopy(data, nonce.Length + tag.Length, cipherBytes, 0, cipherBytes.Length);
        
        using var aes = new AesGcm(key);
        var plainBytes = new byte[cipherBytes.Length];
        aes.Decrypt(nonce, cipherBytes, tag, plainBytes);
        
        return Encoding.UTF8.GetString(plainBytes);
    }
}
```

#### 2.4.2 密钥提供者实现

```csharp
namespace Apq.Cfg.Crypto;

/// <summary>
/// 环境变量密钥提供者
/// </summary>
public sealed class EnvironmentKeyProvider : IKeyProvider
{
    private readonly string _envVarName;
    private readonly byte[]? _cachedKey;

    public EnvironmentKeyProvider(string envVarName = "APQ_CFG_ENCRYPTION_KEY")
    {
        _envVarName = envVarName;
        var keyString = Environment.GetEnvironmentVariable(_envVarName);
        if (!string.IsNullOrEmpty(keyString))
        {
            _cachedKey = Convert.FromBase64String(keyString);
        }
    }

    public int CurrentVersion => 1;

    public byte[] GetKey()
    {
        return _cachedKey ?? throw new InvalidOperationException(
            $"Encryption key not found. Set environment variable '{_envVarName}' with a Base64-encoded 256-bit key.");
    }

    public byte[]? GetKey(int version) => version == 1 ? _cachedKey : null;
}

/// <summary>
/// 文件密钥提供者
/// </summary>
public sealed class FileKeyProvider : IKeyProvider
{
    private readonly Dictionary<int, byte[]> _keys = new();
    private int _currentVersion;

    public FileKeyProvider(string keyFilePath)
    {
        LoadKeys(keyFilePath);
    }

    public int CurrentVersion => _currentVersion;

    public byte[] GetKey() => _keys[_currentVersion];

    public byte[]? GetKey(int version) => _keys.TryGetValue(version, out var key) ? key : null;

    private void LoadKeys(string path)
    {
        // 密钥文件格式（JSON）:
        // { "current": 2, "keys": { "1": "base64...", "2": "base64..." } }
        var json = File.ReadAllText(path);
        var doc = JsonDocument.Parse(json);
        _currentVersion = doc.RootElement.GetProperty("current").GetInt32();
        foreach (var prop in doc.RootElement.GetProperty("keys").EnumerateObject())
        {
            _keys[int.Parse(prop.Name)] = Convert.FromBase64String(prop.Value.GetString()!);
        }
    }
}

/// <summary>
/// Vault 密钥提供者（从 HashiCorp Vault Transit 引擎获取密钥）
/// </summary>
public sealed class VaultKeyProvider : IKeyProvider
{
    // 使用 Vault Transit 引擎进行加解密
    // 密钥永远不离开 Vault
}
```

#### 2.4.3 脱敏提供者实现

```csharp
namespace Apq.Cfg.Crypto;

/// <summary>
/// 默认脱敏提供者
/// </summary>
public sealed class DefaultMaskingProvider : IMaskingProvider
{
    private readonly HashSet<string> _sensitivePatterns = new(StringComparer.OrdinalIgnoreCase)
    {
        "password", "pwd", "secret", "key", "token", "credential",
        "apikey", "api_key", "accesskey", "access_key",
        "connectionstring", "connection_string"
    };

    private readonly List<Regex> _sensitiveRegexes = new();

    public DefaultMaskingProvider()
    {
    }

    public DefaultMaskingProvider(IEnumerable<string> additionalPatterns)
    {
        foreach (var pattern in additionalPatterns)
        {
            _sensitivePatterns.Add(pattern);
        }
    }

    public DefaultMaskingProvider AddPattern(string pattern)
    {
        _sensitivePatterns.Add(pattern);
        return this;
    }

    public DefaultMaskingProvider AddRegex(string regex)
    {
        _sensitiveRegexes.Add(new Regex(regex, RegexOptions.IgnoreCase | RegexOptions.Compiled));
        return this;
    }

    public bool IsSensitive(string key)
    {
        // 检查键名是否包含敏感词
        var keyLower = key.ToLowerInvariant();
        foreach (var pattern in _sensitivePatterns)
        {
            if (keyLower.Contains(pattern, StringComparison.OrdinalIgnoreCase))
                return true;
        }

        // 检查正则匹配
        foreach (var regex in _sensitiveRegexes)
        {
            if (regex.IsMatch(key))
                return true;
        }

        return false;
    }

    public string Mask(string key, string? value)
    {
        if (string.IsNullOrEmpty(value))
            return "[empty]";

        if (!IsSensitive(key))
            return value;

        // 脱敏策略：显示前2后2，中间用*替代
        if (value.Length <= 4)
            return "****";

        return $"{value[..2]}{"*".PadRight(Math.Min(value.Length - 4, 8), '*')}{value[^2..]}";
    }
}
```

### 2.5 CfgBuilder 扩展

```csharp
namespace Apq.Cfg;

public sealed class CfgBuilder
{
    private ICryptoProvider? _cryptoProvider;
    private IKeyProvider? _keyProvider;
    private IMaskingProvider? _maskingProvider;
    private bool _enableEncryption;
    private bool _enableMasking;

    /// <summary>
    /// 启用配置加密
    /// </summary>
    /// <param name="keyProvider">密钥提供者</param>
    /// <param name="cryptoProvider">加密提供者（默认 AES-256-GCM）</param>
    public CfgBuilder WithEncryption(
        IKeyProvider keyProvider,
        ICryptoProvider? cryptoProvider = null)
    {
        _keyProvider = keyProvider;
        _cryptoProvider = cryptoProvider ?? new Aes256GcmCryptoProvider();
        _enableEncryption = true;
        return this;
    }

    /// <summary>
    /// 使用环境变量密钥启用加密
    /// </summary>
    /// <param name="envVarName">环境变量名（默认 APQ_CFG_ENCRYPTION_KEY）</param>
    public CfgBuilder WithEncryptionFromEnv(string envVarName = "APQ_CFG_ENCRYPTION_KEY")
    {
        return WithEncryption(new EnvironmentKeyProvider(envVarName));
    }

    /// <summary>
    /// 使用密钥文件启用加密
    /// </summary>
    /// <param name="keyFilePath">密钥文件路径</param>
    public CfgBuilder WithEncryptionFromFile(string keyFilePath)
    {
        return WithEncryption(new FileKeyProvider(keyFilePath));
    }

    /// <summary>
    /// 启用配置脱敏
    /// </summary>
    /// <param name="maskingProvider">脱敏提供者（默认使用内置规则）</param>
    public CfgBuilder WithMasking(IMaskingProvider? maskingProvider = null)
    {
        _maskingProvider = maskingProvider ?? new DefaultMaskingProvider();
        _enableMasking = true;
        return this;
    }

    /// <summary>
    /// 配置敏感键模式
    /// </summary>
    /// <param name="configure">配置委托</param>
    public CfgBuilder ConfigureSensitiveKeys(Action<DefaultMaskingProvider> configure)
    {
        var provider = new DefaultMaskingProvider();
        configure(provider);
        _maskingProvider = provider;
        _enableMasking = true;
        return this;
    }

    public ICfgRoot Build()
    {
        var root = new MergedCfgRoot(_sources);
        
        if (_enableEncryption && _keyProvider != null && _cryptoProvider != null)
        {
            root = new EncryptedCfgRoot(root, _cryptoProvider, _keyProvider);
        }
        
        if (_enableMasking && _maskingProvider != null)
        {
            root.SetMaskingProvider(_maskingProvider);
        }
        
        return root;
    }
}
```

### 2.6 使用示例

#### 2.6.1 基本加密使用

```csharp
using Apq.Cfg;
using Apq.Cfg.Crypto;

// 方式1：使用环境变量密钥
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: true)
    .WithEncryptionFromEnv("MY_APP_KEY")
    .Build();

// 方式2：使用密钥文件
var cfg2 = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: true)
    .WithEncryptionFromFile("keys.json")
    .Build();

// 方式3：自定义密钥提供者
var cfg3 = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: true)
    .WithEncryption(new VaultKeyProvider(vaultOptions))
    .Build();

// 读取时自动解密
var password = cfg.Get("Database:Password"); // 返回明文

// 写入时自动加密（如果键被标记为敏感）
cfg.Set("Database:Password", "newPassword123");
await cfg.SaveAsync();
// 文件中保存为: "ENC(AES256GCM:1:base64...)"
```

#### 2.6.2 配置脱敏使用

```csharp
using Apq.Cfg;
using Apq.Cfg.Crypto;

var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: true)
    .WithMasking()
    .ConfigureSensitiveKeys(m => m
        .AddPattern("secret")
        .AddPattern("credential")
        .AddRegex(@".*_token$"))
    .Build();

// 获取脱敏后的值（用于日志输出）
var maskedPassword = cfg.GetMasked("Database:Password");
// 输出: "my****rd" (假设原值为 "mypassword")

// 获取所有配置的脱敏快照
var maskedSnapshot = cfg.ToMaskedDictionary();
foreach (var (key, value) in maskedSnapshot)
{
    Console.WriteLine($"{key}: {value}");
}
```

#### 2.6.3 加密工具命令

```bash
# 生成加密密钥
dotnet apqcfg key generate --output keys.json

# 加密配置值
dotnet apqcfg encrypt "mySecretPassword" --key-file keys.json
# 输出: ENC(AES256GCM:1:U2FsdGVkX1+...)

# 解密配置值
dotnet apqcfg decrypt "ENC(AES256GCM:1:U2FsdGVkX1+...)" --key-file keys.json
# 输出: mySecretPassword

# 加密配置文件中的敏感值
dotnet apqcfg encrypt-file config.json --key-file keys.json --patterns "password,secret,key"

# 密钥轮换
dotnet apqcfg key rotate --key-file keys.json --reencrypt config.json
```

---

## 三、项目结构

### 3.1 新增项目

```
Apq.Cfg.Crypto/                    # 加密/脱敏核心库
├── Apq.Cfg.Crypto.csproj
├── README.md
├── ICryptoProvider.cs             # 加密提供者接口
├── IKeyProvider.cs                # 密钥提供者接口
├── IMaskingProvider.cs            # 脱敏提供者接口
├── EncryptedValue.cs              # 加密值解析器
├── Providers/
│   ├── Aes256GcmCryptoProvider.cs # AES-256-GCM 实现
│   ├── Aes256CbcCryptoProvider.cs # AES-256-CBC 实现（兼容旧系统）
│   ├── EnvironmentKeyProvider.cs  # 环境变量密钥
│   ├── FileKeyProvider.cs         # 文件密钥
│   └── DefaultMaskingProvider.cs  # 默认脱敏实现
├── CfgBuilderExtensions.cs        # CfgBuilder 扩展方法
└── EncryptedCfgRoot.cs            # 加密装饰器
```

### 3.2 依赖关系

```
Apq.Cfg.Crypto
├── Apq.Cfg (核心库)
└── System.Security.Cryptography (内置)

Apq.Cfg.Crypto.Vault (可选扩展)
├── Apq.Cfg.Crypto
└── VaultSharp
```

---

## 四、实现计划

### 4.1 第一阶段：核心功能（1 周）

- [ ] 创建 `Apq.Cfg.Crypto` 项目
- [ ] 实现 `ICryptoProvider` 接口和 AES-256-GCM 实现
- [ ] 实现 `IKeyProvider` 接口和环境变量/文件实现
- [ ] 实现 `EncryptedValue` 解析器
- [ ] 实现 `EncryptedCfgRoot` 装饰器
- [ ] 添加 `CfgBuilder` 扩展方法

### 4.2 第二阶段：脱敏功能（3 天）

- [ ] 实现 `IMaskingProvider` 接口
- [ ] 实现 `DefaultMaskingProvider`
- [ ] 添加 `GetMasked()` 和 `ToMaskedDictionary()` 方法
- [ ] 集成到 `ICfgRoot` 接口

### 4.3 第三阶段：测试和文档（3 天）

- [ ] 添加单元测试（加密/解密/脱敏）
- [ ] 添加性能基准测试
- [ ] 编写 README 文档
- [ ] 更新主项目 README

### 4.4 第四阶段：扩展功能（可选）

- [ ] 实现 Vault Transit 密钥提供者
- [ ] 实现 CLI 工具
- [ ] 支持密钥轮换
- [ ] 支持非对称加密（RSA）

---

## 五、安全考虑

### 5.1 密钥管理

1. **密钥不应硬编码**：始终从外部来源（环境变量、文件、Vault）获取
2. **密钥轮换**：支持多版本密钥，便于定期轮换
3. **密钥隔离**：不同环境使用不同密钥
4. **最小权限**：密钥文件权限应限制为仅应用可读

### 5.2 加密算法

1. **推荐 AES-256-GCM**：提供认证加密，防止篡改
2. **避免 ECB 模式**：不安全，不应使用
3. **随机 IV/Nonce**：每次加密使用随机值

### 5.3 脱敏规则

1. **默认保守**：宁可多脱敏，不可少脱敏
2. **可配置**：允许用户自定义敏感键模式
3. **不可逆**：脱敏后的值不应能还原

---

## 六、与现有功能的集成

### 6.1 与 Vault 集成

```csharp
// 使用 Vault Transit 引擎进行加解密
// 密钥永远不离开 Vault，更安全
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0)
    .AddVaultV2(vaultOptions, level: 10)  // Vault 作为配置源
    .WithEncryption(new VaultTransitKeyProvider(vaultOptions))  // Vault 作为密钥源
    .Build();
```

### 6.2 与源生成器集成

```csharp
[CfgSection("Database")]
public partial class DatabaseConfig
{
    public string? Host { get; set; }
    public int Port { get; set; }
    
    [Sensitive]  // 标记为敏感字段
    public string? Password { get; set; }
    
    [Encrypted]  // 标记为需要加密存储
    public string? ConnectionString { get; set; }
}
```

### 6.3 与 DI 集成

```csharp
services.AddApqCfg(cfg => cfg
    .AddJson("config.json", level: 0, writeable: true)
    .WithEncryptionFromEnv()
    .WithMasking());

// 注入加密服务
services.AddSingleton<ICryptoProvider, Aes256GcmCryptoProvider>();
services.AddSingleton<IKeyProvider, EnvironmentKeyProvider>();
```

---

## 七、API 参考

### 7.1 ICfgRoot 扩展

```csharp
public interface ICfgRoot
{
    // 现有方法...
    
    /// <summary>
    /// 获取脱敏后的配置值
    /// </summary>
    string? GetMasked(string key);
    
    /// <summary>
    /// 获取所有配置的脱敏快照
    /// </summary>
    IReadOnlyDictionary<string, string?> ToMaskedDictionary();
    
    /// <summary>
    /// 加密并设置配置值
    /// </summary>
    void SetEncrypted(string key, string? value, int? targetLevel = null);
}
```

### 7.2 CfgBuilder 扩展

```csharp
public sealed class CfgBuilder
{
    // 加密配置
    CfgBuilder WithEncryption(IKeyProvider keyProvider, ICryptoProvider? cryptoProvider = null);
    CfgBuilder WithEncryptionFromEnv(string envVarName = "APQ_CFG_ENCRYPTION_KEY");
    CfgBuilder WithEncryptionFromFile(string keyFilePath);
    
    // 脱敏配置
    CfgBuilder WithMasking(IMaskingProvider? maskingProvider = null);
    CfgBuilder ConfigureSensitiveKeys(Action<DefaultMaskingProvider> configure);
}
```

---

## 八、总结

本方案提供了一个完整的配置加密/脱敏解决方案，具有以下特点：

1. **安全性**：使用 AES-256-GCM 认证加密，支持密钥轮换
2. **灵活性**：支持多种密钥来源，可自定义加密/脱敏提供者
3. **易用性**：通过 `CfgBuilder` 流式 API 配置，与现有代码无缝集成
4. **向后兼容**：可选启用，不影响现有功能
5. **可扩展**：接口设计支持自定义实现

建议按照实现计划分阶段推进，优先完成核心加密功能，再逐步添加脱敏和扩展功能。
