# 配置加密/脱敏功能设计方案

## 一、需求背景

在企业级应用中，配置文件通常包含敏感信息，如：
- 数据库连接字符串（含密码）
- API 密钥和访问令牌
- 第三方服务凭证
- 加密密钥和证书

这些敏感配置如果以明文存储，存在严重的安全风险。需要提供配置加密和脱敏功能来保护敏感数据。

## 二、功能目标

### 2.1 核心功能

1. **配置加密**：对敏感配置值进行加密存储，运行时自动解密
2. **配置脱敏**：在日志输出、调试信息中隐藏敏感配置
3. **密钥管理**：支持多种密钥来源（环境变量、文件、密钥管理服务）
4. **算法可扩展**：支持多种加密算法，可自定义扩展

### 2.2 设计原则

- **透明性**：对业务代码透明，无需修改现有配置读取逻辑
- **安全性**：遵循安全最佳实践，支持行业标准加密算法
- **灵活性**：支持按需加密，可指定哪些配置需要加密
- **兼容性**：与现有配置源无缝集成

## 三、技术方案

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                      应用层                                  │
│  cfgRoot.Get<string>("Database:Password")  // 自动解密      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   ICfgRoot / ICfgSection                     │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              IConfigDecryptor (解密拦截器)            │   │
│  │  - 识别加密标记 ENC(...)                              │   │
│  │  - 调用解密提供者解密                                  │   │
│  │  - 返回明文值                                         │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    IEncryptionProvider                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │   AES    │  │  RSA     │  │  DPAPI   │  │  Custom  │   │
│  │ Provider │  │ Provider │  │ Provider │  │ Provider │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     IKeyProvider                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ EnvVar   │  │  File    │  │  Vault   │  │  Azure   │   │
│  │ Provider │  │ Provider │  │ Provider │  │ KeyVault │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心接口设计

#### 3.2.1 加密提供者接口

```csharp
namespace Apq.Cfg.Encryption;

/// <summary>
/// 加密提供者接口
/// </summary>
public interface IEncryptionProvider
{
    /// <summary>
    /// 提供者名称（用于配置标识）
    /// </summary>
    string Name { get; }
    
    /// <summary>
    /// 加密明文
    /// </summary>
    string Encrypt(string plainText, EncryptionContext context);
    
    /// <summary>
    /// 解密密文
    /// </summary>
    string Decrypt(string cipherText, EncryptionContext context);
}

/// <summary>
/// 加密上下文
/// </summary>
public class EncryptionContext
{
    /// <summary>
    /// 配置键路径
    /// </summary>
    public string KeyPath { get; set; }
    
    /// <summary>
    /// 密钥提供者
    /// </summary>
    public IKeyProvider KeyProvider { get; set; }
    
    /// <summary>
    /// 附加参数
    /// </summary>
    public IDictionary<string, string> Parameters { get; set; }
}
```

#### 3.2.2 密钥提供者接口

```csharp
namespace Apq.Cfg.Encryption;

/// <summary>
/// 密钥提供者接口
/// </summary>
public interface IKeyProvider
{
    /// <summary>
    /// 获取加密密钥
    /// </summary>
    byte[] GetKey(string keyId = null);
    
    /// <summary>
    /// 获取初始化向量（如适用）
    /// </summary>
    byte[] GetIV(string keyId = null);
}

/// <summary>
/// 环境变量密钥提供者
/// </summary>
public class EnvironmentKeyProvider : IKeyProvider
{
    private readonly string _keyEnvVar;
    private readonly string _ivEnvVar;
    
    public EnvironmentKeyProvider(string keyEnvVar = "APQ_CFG_KEY", string ivEnvVar = "APQ_CFG_IV")
    {
        _keyEnvVar = keyEnvVar;
        _ivEnvVar = ivEnvVar;
    }
    
    public byte[] GetKey(string keyId = null) 
        => Convert.FromBase64String(Environment.GetEnvironmentVariable(_keyEnvVar) 
            ?? throw new InvalidOperationException($"环境变量 {_keyEnvVar} 未设置"));
    
    public byte[] GetIV(string keyId = null)
        => Convert.FromBase64String(Environment.GetEnvironmentVariable(_ivEnvVar) 
            ?? throw new InvalidOperationException($"环境变量 {_ivEnvVar} 未设置"));
}
```

#### 3.2.3 配置解密器接口

```csharp
namespace Apq.Cfg.Encryption;

/// <summary>
/// 配置解密器接口
/// </summary>
public interface IConfigDecryptor
{
    /// <summary>
    /// 判断值是否为加密值
    /// </summary>
    bool IsEncrypted(string value);
    
    /// <summary>
    /// 解密配置值
    /// </summary>
    string Decrypt(string encryptedValue);
}

/// <summary>
/// 默认配置解密器实现
/// </summary>
public class DefaultConfigDecryptor : IConfigDecryptor
{
    // 加密值格式: ENC(algorithm:ciphertext) 或 ENC(ciphertext)
    private static readonly Regex EncryptedPattern = new(@"^ENC\((?:(\w+):)?(.+)\)$", RegexOptions.Compiled);
    
    private readonly IDictionary<string, IEncryptionProvider> _providers;
    private readonly string _defaultProvider;
    private readonly IKeyProvider _keyProvider;
    
    public DefaultConfigDecryptor(
        IEnumerable<IEncryptionProvider> providers,
        IKeyProvider keyProvider,
        string defaultProvider = "AES")
    {
        _providers = providers.ToDictionary(p => p.Name, StringComparer.OrdinalIgnoreCase);
        _keyProvider = keyProvider;
        _defaultProvider = defaultProvider;
    }
    
    public bool IsEncrypted(string value)
        => !string.IsNullOrEmpty(value) && EncryptedPattern.IsMatch(value);
    
    public string Decrypt(string encryptedValue)
    {
        var match = EncryptedPattern.Match(encryptedValue);
        if (!match.Success)
            throw new ArgumentException("无效的加密值格式", nameof(encryptedValue));
        
        var algorithm = match.Groups[1].Success ? match.Groups[1].Value : _defaultProvider;
        var cipherText = match.Groups[2].Value;
        
        if (!_providers.TryGetValue(algorithm, out var provider))
            throw new NotSupportedException($"不支持的加密算法: {algorithm}");
        
        var context = new EncryptionContext { KeyProvider = _keyProvider };
        return provider.Decrypt(cipherText, context);
    }
}
```

### 3.3 内置加密提供者

#### 3.3.1 AES 加密提供者

```csharp
namespace Apq.Cfg.Encryption.Providers;

/// <summary>
/// AES 对称加密提供者
/// </summary>
public class AesEncryptionProvider : IEncryptionProvider
{
    public string Name => "AES";
    
    public string Encrypt(string plainText, EncryptionContext context)
    {
        using var aes = Aes.Create();
        aes.Key = context.KeyProvider.GetKey();
        aes.IV = context.KeyProvider.GetIV();
        
        using var encryptor = aes.CreateEncryptor();
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var cipherBytes = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);
        
        return Convert.ToBase64String(cipherBytes);
    }
    
    public string Decrypt(string cipherText, EncryptionContext context)
    {
        using var aes = Aes.Create();
        aes.Key = context.KeyProvider.GetKey();
        aes.IV = context.KeyProvider.GetIV();
        
        using var decryptor = aes.CreateDecryptor();
        var cipherBytes = Convert.FromBase64String(cipherText);
        var plainBytes = decryptor.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);
        
        return Encoding.UTF8.GetString(plainBytes);
    }
}
```

#### 3.3.2 DPAPI 加密提供者（Windows 专用）

```csharp
namespace Apq.Cfg.Encryption.Providers;

/// <summary>
/// Windows DPAPI 加密提供者（机器级或用户级保护）
/// </summary>
public class DpapiEncryptionProvider : IEncryptionProvider
{
    private readonly DataProtectionScope _scope;
    
    public DpapiEncryptionProvider(DataProtectionScope scope = DataProtectionScope.CurrentUser)
    {
        _scope = scope;
    }
    
    public string Name => "DPAPI";
    
    public string Encrypt(string plainText, EncryptionContext context)
    {
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var cipherBytes = ProtectedData.Protect(plainBytes, null, _scope);
        return Convert.ToBase64String(cipherBytes);
    }
    
    public string Decrypt(string cipherText, EncryptionContext context)
    {
        var cipherBytes = Convert.FromBase64String(cipherText);
        var plainBytes = ProtectedData.Unprotect(cipherBytes, null, _scope);
        return Encoding.UTF8.GetString(plainBytes);
    }
}
```

#### 3.3.3 RSA 非对称加密提供者

```csharp
namespace Apq.Cfg.Encryption.Providers;

/// <summary>
/// RSA 非对称加密提供者
/// </summary>
public class RsaEncryptionProvider : IEncryptionProvider
{
    public string Name => "RSA";
    
    public string Encrypt(string plainText, EncryptionContext context)
    {
        using var rsa = RSA.Create();
        rsa.ImportRSAPublicKey(context.KeyProvider.GetKey("public"), out _);
        
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var cipherBytes = rsa.Encrypt(plainBytes, RSAEncryptionPadding.OaepSHA256);
        
        return Convert.ToBase64String(cipherBytes);
    }
    
    public string Decrypt(string cipherText, EncryptionContext context)
    {
        using var rsa = RSA.Create();
        rsa.ImportRSAPrivateKey(context.KeyProvider.GetKey("private"), out _);
        
        var cipherBytes = Convert.FromBase64String(cipherText);
        var plainBytes = rsa.Decrypt(cipherBytes, RSAEncryptionPadding.OaepSHA256);
        
        return Encoding.UTF8.GetString(plainBytes);
    }
}
```

### 3.4 配置脱敏功能

#### 3.4.1 脱敏接口

```csharp
namespace Apq.Cfg.Masking;

/// <summary>
/// 配置脱敏器接口
/// </summary>
public interface IConfigMasker
{
    /// <summary>
    /// 判断配置键是否需要脱敏
    /// </summary>
    bool ShouldMask(string keyPath);
    
    /// <summary>
    /// 对配置值进行脱敏
    /// </summary>
    string Mask(string value, string keyPath);
}

/// <summary>
/// 默认配置脱敏器
/// </summary>
public class DefaultConfigMasker : IConfigMasker
{
    private readonly HashSet<string> _sensitivePatterns;
    private readonly string _maskChar;
    private readonly int _visibleChars;
    
    public DefaultConfigMasker(
        IEnumerable<string> sensitivePatterns = null,
        string maskChar = "*",
        int visibleChars = 4)
    {
        _sensitivePatterns = new HashSet<string>(
            sensitivePatterns ?? GetDefaultSensitivePatterns(),
            StringComparer.OrdinalIgnoreCase);
        _maskChar = maskChar;
        _visibleChars = visibleChars;
    }
    
    private static IEnumerable<string> GetDefaultSensitivePatterns() => new[]
    {
        "password", "pwd", "secret", "key", "token", "apikey",
        "connectionstring", "credentials", "auth", "private"
    };
    
    public bool ShouldMask(string keyPath)
    {
        if (string.IsNullOrEmpty(keyPath)) return false;
        
        var segments = keyPath.Split(':');
        return segments.Any(s => _sensitivePatterns.Any(p => 
            s.Contains(p, StringComparison.OrdinalIgnoreCase)));
    }
    
    public string Mask(string value, string keyPath)
    {
        if (string.IsNullOrEmpty(value)) return value;
        if (value.Length <= _visibleChars) return new string(_maskChar[0], value.Length);
        
        return value[.._visibleChars] + new string(_maskChar[0], value.Length - _visibleChars);
    }
}
```

#### 3.4.2 脱敏特性

```csharp
namespace Apq.Cfg.Masking;

/// <summary>
/// 标记属性为敏感配置，在日志输出时自动脱敏
/// </summary>
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class SensitiveAttribute : Attribute
{
    /// <summary>
    /// 脱敏策略
    /// </summary>
    public MaskStrategy Strategy { get; set; } = MaskStrategy.PartialMask;
    
    /// <summary>
    /// 保留可见字符数
    /// </summary>
    public int VisibleChars { get; set; } = 4;
}

/// <summary>
/// 脱敏策略
/// </summary>
public enum MaskStrategy
{
    /// <summary>
    /// 完全隐藏
    /// </summary>
    FullMask,
    
    /// <summary>
    /// 部分隐藏（保留前几位）
    /// </summary>
    PartialMask,
    
    /// <summary>
    /// 仅显示长度
    /// </summary>
    LengthOnly,
    
    /// <summary>
    /// 显示为固定占位符
    /// </summary>
    Placeholder
}
```

### 3.5 CfgBuilder 集成

```csharp
namespace Apq.Cfg;

public static class CfgBuilderEncryptionExtensions
{
    /// <summary>
    /// 启用配置加密支持
    /// </summary>
    public static CfgBuilder WithEncryption(
        this CfgBuilder builder,
        Action<EncryptionOptions> configure = null)
    {
        var options = new EncryptionOptions();
        configure?.Invoke(options);
        
        builder.Services.AddSingleton(options);
        builder.Services.AddSingleton<IConfigDecryptor, DefaultConfigDecryptor>();
        
        // 注册默认加密提供者
        builder.Services.AddSingleton<IEncryptionProvider, AesEncryptionProvider>();
        
        // 注册密钥提供者
        if (options.KeyProvider != null)
            builder.Services.AddSingleton(options.KeyProvider);
        else
            builder.Services.AddSingleton<IKeyProvider, EnvironmentKeyProvider>();
        
        return builder;
    }
    
    /// <summary>
    /// 使用 AES 加密
    /// </summary>
    public static CfgBuilder WithAesEncryption(
        this CfgBuilder builder,
        string keyEnvVar = "APQ_CFG_KEY",
        string ivEnvVar = "APQ_CFG_IV")
    {
        return builder.WithEncryption(options =>
        {
            options.DefaultAlgorithm = "AES";
            options.KeyProvider = new EnvironmentKeyProvider(keyEnvVar, ivEnvVar);
        });
    }
    
    /// <summary>
    /// 使用 DPAPI 加密（Windows）
    /// </summary>
    public static CfgBuilder WithDpapiEncryption(
        this CfgBuilder builder,
        DataProtectionScope scope = DataProtectionScope.CurrentUser)
    {
        return builder.WithEncryption(options =>
        {
            options.DefaultAlgorithm = "DPAPI";
            options.Providers.Add(new DpapiEncryptionProvider(scope));
        });
    }
    
    /// <summary>
    /// 启用配置脱敏
    /// </summary>
    public static CfgBuilder WithMasking(
        this CfgBuilder builder,
        Action<MaskingOptions> configure = null)
    {
        var options = new MaskingOptions();
        configure?.Invoke(options);
        
        builder.Services.AddSingleton(options);
        builder.Services.AddSingleton<IConfigMasker, DefaultConfigMasker>();
        
        return builder;
    }
}

/// <summary>
/// 加密选项
/// </summary>
public class EncryptionOptions
{
    /// <summary>
    /// 默认加密算法
    /// </summary>
    public string DefaultAlgorithm { get; set; } = "AES";
    
    /// <summary>
    /// 密钥提供者
    /// </summary>
    public IKeyProvider KeyProvider { get; set; }
    
    /// <summary>
    /// 加密提供者列表
    /// </summary>
    public List<IEncryptionProvider> Providers { get; } = new();
    
    /// <summary>
    /// 是否启用自动解密
    /// </summary>
    public bool AutoDecrypt { get; set; } = true;
}

/// <summary>
/// 脱敏选项
/// </summary>
public class MaskingOptions
{
    /// <summary>
    /// 敏感配置键模式
    /// </summary>
    public List<string> SensitivePatterns { get; } = new()
    {
        "password", "pwd", "secret", "key", "token", "apikey",
        "connectionstring", "credentials", "auth", "private"
    };
    
    /// <summary>
    /// 脱敏字符
    /// </summary>
    public string MaskChar { get; set; } = "*";
    
    /// <summary>
    /// 保留可见字符数
    /// </summary>
    public int VisibleChars { get; set; } = 4;
}
```

## 四、使用示例

### 4.1 配置文件示例

```json
{
  "Database": {
    "Host": "localhost",
    "Port": 5432,
    "Username": "admin",
    "Password": "ENC(AES:SGVsbG8gV29ybGQh)"
  },
  "Redis": {
    "ConnectionString": "ENC(localhost:6379,password=SGVsbG8gV29ybGQh)"
  },
  "ApiKeys": {
    "ThirdParty": "ENC(RSA:base64encodedciphertext)"
  }
}
```

### 4.2 代码使用示例

```csharp
// 配置加密
var cfgRoot = new CfgBuilder()
    .AddJsonFile("appsettings.json")
    .WithAesEncryption()  // 使用 AES 加密，密钥从环境变量读取
    .WithMasking(options =>
    {
        options.SensitivePatterns.Add("connectionstring");
        options.VisibleChars = 4;
    })
    .Build();

// 读取配置时自动解密
var password = cfgRoot.Get<string>("Database:Password");  // 返回明文

// 获取脱敏后的配置（用于日志）
var maskedConfig = cfgRoot.GetMasked("Database:Password");  // 返回 "pass****"

// 使用 DPAPI（Windows）
var cfgRoot = new CfgBuilder()
    .AddJsonFile("appsettings.json")
    .WithDpapiEncryption(DataProtectionScope.CurrentUser)
    .Build();
```

### 4.3 加密工具使用

```csharp
// 加密配置值
var encryptor = new ConfigEncryptor(new AesEncryptionProvider(), keyProvider);
var encrypted = encryptor.Encrypt("my-secret-password");
// 输出: ENC(AES:SGVsbG8gV29ybGQh)

// 批量加密配置文件
await ConfigEncryptor.EncryptFileAsync(
    "appsettings.json",
    "appsettings.encrypted.json",
    new[] { "Database:Password", "Redis:Password" });
```

### 4.4 CLI 工具（未来扩展）

```bash
# 加密单个值
dotnet apqcfg encrypt "my-secret" --algorithm AES --key-env APQ_CFG_KEY

# 加密配置文件中的指定键
dotnet apqcfg encrypt-file appsettings.json --keys "Database:Password,Redis:Password"

# 解密配置文件（用于调试）
dotnet apqcfg decrypt-file appsettings.encrypted.json --output appsettings.decrypted.json

# 生成加密密钥
dotnet apqcfg generate-key --algorithm AES --output key.txt
```

## 五、项目结构

```
Apq.Cfg.Encryption/
├── Apq.Cfg.Encryption.csproj
├── README.md
├── IEncryptionProvider.cs
├── IKeyProvider.cs
├── IConfigDecryptor.cs
├── EncryptionOptions.cs
├── CfgBuilderExtensions.cs
├── Providers/
│   ├── AesEncryptionProvider.cs
│   ├── RsaEncryptionProvider.cs
│   └── DpapiEncryptionProvider.cs
├── KeyProviders/
│   ├── EnvironmentKeyProvider.cs
│   ├── FileKeyProvider.cs
│   └── VaultKeyProvider.cs
├── Masking/
│   ├── IConfigMasker.cs
│   ├── DefaultConfigMasker.cs
│   ├── SensitiveAttribute.cs
│   └── MaskingOptions.cs
└── Tools/
    └── ConfigEncryptor.cs
```

## 六、实现计划

### 阶段一：核心功能（1 周）

- [ ] 实现 `IEncryptionProvider` 接口和 AES 提供者
- [ ] 实现 `IKeyProvider` 接口和环境变量提供者
- [ ] 实现 `IConfigDecryptor` 和自动解密逻辑
- [ ] 集成到 `CfgBuilder`

### 阶段二：扩展功能（1 周）

- [ ] 实现 DPAPI 提供者（Windows）
- [ ] 实现 RSA 非对称加密提供者
- [ ] 实现文件密钥提供者
- [ ] 实现配置脱敏功能

### 阶段三：工具和文档（1 周）

- [ ] 实现 `ConfigEncryptor` 工具类
- [ ] 编写单元测试
- [ ] 编写使用文档和示例
- [ ] 发布 NuGet 包

## 七、安全考虑

1. **密钥管理**
   - 密钥不应硬编码在代码中
   - 推荐使用环境变量或密钥管理服务
   - 支持密钥轮换机制

2. **算法选择**
   - AES-256 作为默认对称加密算法
   - RSA-2048 或更高用于非对称加密
   - 避免使用已知不安全的算法（如 DES、MD5）

3. **内存安全**
   - 解密后的敏感数据应尽快清除
   - 考虑使用 `SecureString`（虽然已不推荐）
   - 避免在日志中输出敏感信息

4. **审计日志**
   - 记录加密/解密操作（不含敏感数据）
   - 记录密钥访问事件
   - 支持安全审计需求

## 八、与现有功能的集成

### 8.1 与 Vault 集成

```csharp
// 使用 Vault 作为密钥提供者
var cfgRoot = new CfgBuilder()
    .AddJsonFile("appsettings.json")
    .AddVault(options => { /* Vault 配置 */ })
    .WithEncryption(options =>
    {
        options.KeyProvider = new VaultKeyProvider("secret/data/encryption-key");
    })
    .Build();
```

### 8.2 与热重载集成

加密配置支持热重载，当配置文件变更时：
1. 重新读取加密配置
2. 使用当前密钥解密
3. 触发配置变更通知

## 九、总结

本方案提供了完整的配置加密/脱敏解决方案：

1. **灵活的加密架构**：支持多种加密算法和密钥来源
2. **透明的集成方式**：对业务代码无侵入
3. **完善的脱敏功能**：保护日志和调试输出中的敏感信息
4. **可扩展的设计**：易于添加新的加密提供者和密钥来源

建议按照实现计划分阶段推进，优先实现 AES 加密和环境变量密钥提供者，满足基本安全需求后再扩展其他功能。
