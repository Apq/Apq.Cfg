# Apq.Cfg 功能建议与优化改进

> 分析日期：2026-01-02
> 基于版本：当前 master 分支

---

## 一、项目现状总结

### 1.1 项目规模

| 指标 | 数值 |
|------|------|
| NuGet 包数量 | 17 个 |
| 核心源文件 | 50+ 个 |
| 单元测试 | 429 个（388 通过，41 跳过需外部服务） |
| 性能基准测试 | 280+ 个测试方法 |
| 目标框架 | net8.0, net10.0 (LTS) |
| API 测试覆盖率 | 100% |

### 1.2 已实现功能

**核心功能**：
- ✅ 多配置源合并（层级优先级）
- ✅ 类型安全的配置读取
- ✅ 配置写入与持久化
- ✅ 动态重载与变更订阅
- ✅ 配置节访问
- ✅ 批量操作（含零堆分配版本）
- ✅ Microsoft.Extensions.Configuration 集成
- ✅ 依赖注入集成（IOptions 模式）
- ✅ 编码自动检测与转换
- ✅ 加密与脱敏
- ✅ Native AOT 支持（源生成器）

**支持的配置源**：
- ✅ 文件格式：JSON、YAML、XML、INI、TOML、.env
- ✅ 远程配置中心：Consul、Etcd、Nacos、Apollo、Zookeeper
- ✅ 存储：Redis、Database（SQL Server/MySQL/PostgreSQL/Oracle/SQLite）
- ✅ 密钥管理：HashiCorp Vault
- ✅ 环境变量

---

## 二、新功能建议

### 2.1 高优先级（P0）

#### 2.1.1 配置验证框架

**需求描述**：
当前缺少内置的配置值验证机制，用户需要手动验证配置值的有效性。

**建议实现**：

```csharp
// 1. 定义验证接口
public interface IConfigValidator
{
    ValidationResult Validate(ICfgRoot cfg);
}

// 2. 内置验证规则
public class ConfigValidationBuilder
{
    public ConfigValidationBuilder Required(string key);
    public ConfigValidationBuilder Range<T>(string key, T min, T max) where T : IComparable<T>;
    public ConfigValidationBuilder Regex(string key, string pattern);
    public ConfigValidationBuilder Custom(string key, Func<string?, bool> validator, string errorMessage);
    public ConfigValidationBuilder DependsOn(string key, string dependencyKey);
}

// 3. 使用示例
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0)
    .AddValidation(v => v
        .Required("Database:ConnectionString")
        .Range("Database:Port", 1, 65535)
        .Regex("App:Email", @"^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$"))
    .Build();

// 4. 启动时验证
var result = cfg.Validate();
if (!result.IsValid)
{
    foreach (var error in result.Errors)
    {
        Console.WriteLine($"配置错误: {error.Key} - {error.Message}");
    }
}
```

**工作量估计**：3-5 天

---

#### 2.1.2 配置快照导出

**需求描述**：
支持将当前配置状态导出为文件，便于调试、备份和迁移。

**建议实现**：

```csharp
// 1. 导出接口
public interface IConfigExporter
{
    Task ExportAsync(ICfgRoot cfg, Stream output, ExportOptions? options = null);
    string Export(ICfgRoot cfg, ExportOptions? options = null);
}

// 2. 导出选项
public class ExportOptions
{
    public ExportFormat Format { get; set; } = ExportFormat.Json;
    public bool IncludeMetadata { get; set; } = false;
    public bool MaskSensitiveValues { get; set; } = true;
    public string[]? IncludeKeys { get; set; }
    public string[]? ExcludeKeys { get; set; }
}

public enum ExportFormat { Json, Yaml, Toml }

// 3. 使用示例
var exporter = new ConfigExporter();
var json = exporter.Export(cfg, new ExportOptions
{
    Format = ExportFormat.Json,
    MaskSensitiveValues = true,
    ExcludeKeys = new[] { "Secrets:*" }
});

await File.WriteAllTextAsync("config-snapshot.json", json);
```

**工作量估计**：2-3 天

---

### 2.2 中优先级（P1）

#### 2.2.1 日志集成

**需求描述**：
添加 `ILogger` 支持，便于调试配置加载、变更和错误。

**建议实现**：

```csharp
// 1. 构建器扩展
var cfg = new CfgBuilder()
    .WithLogging(loggerFactory)  // 或 .WithLogging(logger)
    .AddJson("config.json", level: 0)
    .Build();

// 2. 日志输出示例
// [INF] Apq.Cfg: Loading configuration from config.json
// [INF] Apq.Cfg: Loaded 42 configuration keys from config.json
// [DBG] Apq.Cfg: Configuration key 'Database:Host' = 'localhost'
// [WRN] Apq.Cfg: Configuration file config.local.json not found (optional)
// [INF] Apq.Cfg: Configuration changed: Database:Port (5432 -> 5433)
```

**工作量估计**：1-2 天

---

#### 2.2.2 配置差异对比

**需求描述**：
提供配置状态对比功能，便于发现配置变更。

**建议实现**：

```csharp
// 1. 差异接口
public interface IConfigDiff
{
    IReadOnlyList<ConfigChange> Changes { get; }
    bool HasChanges { get; }
}

public class ConfigChange
{
    public string Key { get; }
    public string? OldValue { get; }
    public string? NewValue { get; }
    public ChangeType Type { get; } // Added, Modified, Removed
}

// 2. 使用示例
var snapshot1 = cfg.CreateSnapshot();
// ... 配置变更 ...
var snapshot2 = cfg.CreateSnapshot();

var diff = snapshot1.CompareTo(snapshot2);
foreach (var change in diff.Changes)
{
    Console.WriteLine($"[{change.Type}] {change.Key}: {change.OldValue} -> {change.NewValue}");
}
```

**工作量估计**：2-3 天

---

#### 2.2.3 配置模板与变量替换

**需求描述**：
支持配置值中的变量引用，减少重复配置。

**建议实现**：

```json
{
  "App": {
    "Name": "MyApp",
    "DataDir": "/var/data/${App:Name}",
    "LogDir": "${env:HOME}/logs/${App:Name}",
    "ConnectionString": "Host=${Database:Host};Port=${Database:Port}"
  },
  "Database": {
    "Host": "localhost",
    "Port": 5432
  }
}
```

```csharp
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0)
    .EnableVariableExpansion(options =>
    {
        options.Prefix = "${";
        options.Suffix = "}";
        options.EnvironmentVariablePrefix = "env:";
        options.MaxRecursionDepth = 10;
    })
    .Build();

// cfg["App:DataDir"] 返回 "/var/data/MyApp"
// cfg["App:LogDir"] 返回 "/home/user/logs/MyApp"
```

**工作量估计**：3-4 天

---

#### 2.2.4 配置继承

**需求描述**：
支持配置节继承，减少重复配置。

**建议实现**：

```json
{
  "Database:Default": {
    "Port": 5432,
    "Timeout": 30,
    "MaxConnections": 100
  },
  "Database:Primary": {
    "$inherit": "Database:Default",
    "Host": "primary-db.example.com"
  },
  "Database:Replica": {
    "$inherit": "Database:Default",
    "Host": "replica-db.example.com",
    "MaxConnections": 50
  }
}
```

```csharp
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0)
    .EnableInheritance(options =>
    {
        options.InheritKey = "$inherit";
    })
    .Build();

// cfg["Database:Primary:Port"] 返回 "5432"（继承自 Default）
// cfg["Database:Replica:MaxConnections"] 返回 "50"（覆盖 Default）
```

**工作量估计**：3-4 天

---

### 2.3 低优先级（P2）

#### 2.3.1 云配置服务支持

**AWS Parameter Store**：

```csharp
var cfg = new CfgBuilder()
    .AddAwsParameterStore(options =>
    {
        options.Path = "/myapp/config/";
        options.Region = "us-east-1";
        options.EnableHotReload = true;
    }, level: 10)
    .Build();
```

**Azure App Configuration**：

```csharp
var cfg = new CfgBuilder()
    .AddAzureAppConfiguration(options =>
    {
        options.ConnectionString = "Endpoint=...";
        options.LabelFilter = "Production";
        options.EnableHotReload = true;
    }, level: 10)
    .Build();
```

**工作量估计**：每个 5-7 天

---

#### 2.3.2 配置审计日志

**需求描述**：
记录所有配置变更的审计日志，满足合规要求。

**建议实现**：

```csharp
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: true)
    .EnableAuditLog(options =>
    {
        options.LogWriter = new FileAuditLogWriter("config-audit.log");
        options.IncludeOldValue = true;
        options.IncludeNewValue = false; // 敏感值不记录
        options.IncludeTimestamp = true;
        options.IncludeUser = true;
    })
    .Build();

// 审计日志格式
// 2026-01-02T10:30:00Z | user@example.com | SET | Database:Password | *** -> ***
// 2026-01-02T10:31:00Z | admin@example.com | DELETE | OldConfig:Key | value -> null
```

**工作量估计**：2-3 天

---

#### 2.3.3 配置健康检查

**需求描述**：
提供 ASP.NET Core 健康检查集成。

**建议实现**：

```csharp
// 注册健康检查
services.AddHealthChecks()
    .AddApqCfgCheck("config", options =>
    {
        options.RequiredKeys = new[] { "Database:ConnectionString", "App:Name" };
        options.CheckRemoteSources = true;
        options.Timeout = TimeSpan.FromSeconds(5);
    });

// 健康检查端点
app.MapHealthChecks("/health");
```

**工作量估计**：1-2 天

---

#### 2.3.4 配置锁定

**需求描述**：
支持锁定特定配置键，防止运行时修改。

**建议实现**：

```csharp
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0, writeable: true)
    .LockKeys("Database:ConnectionString", "App:SecretKey")
    .Build();

// 尝试修改锁定的键会抛出异常
cfg["Database:ConnectionString"] = "new-value"; // throws ConfigurationLockedException
```

**工作量估计**：1 天

---

## 三、性能优化建议

### 3.1 字符串池化

**当前问题**：
频繁访问的配置键每次都创建新字符串。

**优化方案**：

```csharp
// 在 MergedCfgRoot 中添加键池化
private readonly ConcurrentDictionary<string, string> _keyPool = new();

private string InternKey(string key)
{
    return _keyPool.GetOrAdd(key, k => string.Intern(k));
}
```

**预期收益**：减少 GC 压力，提升高频访问性能 10-20%

---

### 3.2 Span<T> 优化键路径解析

**当前问题**：
键路径解析使用 `string.Split()` 产生数组分配。

**优化方案**：

```csharp
// 使用 Span<T> 避免分配
public static bool TryParsePath(ReadOnlySpan<char> path, out ReadOnlySpan<char> segment, out ReadOnlySpan<char> remaining)
{
    var index = path.IndexOf(':');
    if (index < 0)
    {
        segment = path;
        remaining = ReadOnlySpan<char>.Empty;
        return true;
    }

    segment = path.Slice(0, index);
    remaining = path.Slice(index + 1);
    return true;
}
```

**预期收益**：键路径解析零分配，提升性能 30-50%

---

### 3.3 ValueTask 优化

**当前问题**：
部分同步完成的异步操作使用 `Task` 返回类型。

**优化方案**：

```csharp
// 将同步完成的操作改为 ValueTask
public ValueTask ApplyChangesAsync(IReadOnlyDictionary<string, string?> changes, CancellationToken cancellationToken = default)
{
    if (changes.Count == 0)
        return ValueTask.CompletedTask;

    // 实际异步操作
    return new ValueTask(ApplyChangesInternalAsync(changes, cancellationToken));
}
```

**预期收益**：减少异步状态机分配，提升高频调用性能

---

### 3.4 配置缓存预热

**当前问题**：
首次访问配置时需要遍历所有层级。

**优化方案**：

```csharp
// 添加预热方法
public void Warmup(params string[] keys)
{
    foreach (var key in keys)
    {
        _ = this[key]; // 触发缓存
    }
}

// 或自动预热常用键
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0)
    .EnableWarmup(options =>
    {
        options.Keys = new[] { "Database:*", "App:*" };
        options.WarmupOnBuild = true;
    })
    .Build();
```

**预期收益**：首次访问延迟降低 50%+

---

## 四、代码质量改进

### 4.1 异常处理增强

**当前问题**：
远程配置源的异常处理较为粗糙，难以区分不同类型的错误。

**改进方案**：

```csharp
// 1. 定义专用异常类型
public class ConfigSourceException : Exception
{
    public string SourceName { get; }
    public ConfigSourceErrorType ErrorType { get; }
}

public enum ConfigSourceErrorType
{
    ConnectionFailed,
    AuthenticationFailed,
    Timeout,
    NotFound,
    PermissionDenied,
    InvalidData
}

// 2. 添加错误回调
var cfg = new CfgBuilder()
    .AddConsul(options => { ... }, level: 10)
    .OnSourceError((source, ex) =>
    {
        logger.LogError(ex, "配置源 {Source} 发生错误", source.Name);
        // 可选：切换到备用源
    })
    .Build();
```

---

### 4.2 取消令牌传播

**当前问题**：
部分异步操作未正确传播 `CancellationToken`。

**改进方案**：

```csharp
// 确保所有异步方法都接受并传播 CancellationToken
public async Task<ICfgRoot> BuildAsync(CancellationToken cancellationToken = default)
{
    foreach (var source in _sources)
    {
        cancellationToken.ThrowIfCancellationRequested();
        await source.InitializeAsync(cancellationToken);
    }
    // ...
}
```

---

### 4.3 Nullable 注解完善

**当前问题**：
部分 API 的 nullable 注解不够精确。

**改进方案**：

```csharp
// 使用 [NotNullWhen] 等特性
public bool TryGet<T>(string key, [NotNullWhen(true)] out T? value)
{
    // ...
}

// 使用 [MemberNotNull] 特性
[MemberNotNull(nameof(_data))]
private void EnsureInitialized()
{
    _data ??= new Dictionary<string, string?>();
}
```

---

## 五、API 改进建议

### 5.1 流式 API

```csharp
// 当前
var section = cfg.GetSection("Database");
var host = section["Host"];

// 建议添加流式 API
cfg.GetSection("Database")
   .Bind<DatabaseOptions>()
   .Validate(options => options.Port > 0, "Port must be positive")
   .OnChange(options => ReconnectDatabase(options));
```

---

### 5.2 构建器增强

```csharp
// 建议添加更多配置源加载方式
builder
    .AddJsonFromUrl("https://config.example.com/config.json", level: 5)
    .AddJsonFromStream(stream, level: 6)
    .AddJsonFromString(jsonString, level: 7)
    .AddJsonFromEmbeddedResource("MyApp.config.json", level: 0);
```

---

### 5.3 批量操作增强

```csharp
// 建议添加异步批量操作
await cfg.GetManyAsync(keys, cancellationToken);
await cfg.SetManyAsync(values, cancellationToken);

// 建议添加条件批量操作
cfg.SetManyIf(values, key => !cfg.Exists(key)); // 仅设置不存在的键
```

---

## 六、测试改进建议

### 6.1 集成测试自动化

**当前问题**：
41 个测试因需要外部服务而跳过。

**改进方案**：

```yaml
# docker-compose.test.yml
version: '3.8'
services:
  redis:
    image: redis:7-alpine
    ports: ["6379:6379"]

  consul:
    image: consul:1.15
    ports: ["8500:8500"]

  etcd:
    image: quay.io/coreos/etcd:v3.5.9
    ports: ["2379:2379"]

  nacos:
    image: nacos/nacos-server:v2.2.3
    ports: ["8848:8848"]

  zookeeper:
    image: zookeeper:3.8
    ports: ["2181:2181"]

  vault:
    image: vault:1.13
    ports: ["8200:8200"]
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: test-token
```

```bash
# CI 脚本
docker-compose -f docker-compose.test.yml up -d
dotnet test --filter "Category!=RequiresExternalService"
docker-compose -f docker-compose.test.yml down
```

---

### 6.2 性能回归测试

**改进方案**：

```yaml
# .github/workflows/benchmark.yml
name: Performance Benchmark
on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Benchmarks
        run: dotnet run -c Release --project benchmarks/Apq.Cfg.Benchmarks -- --export json
      - name: Compare with Baseline
        uses: benchmark-action/github-action-benchmark@v1
        with:
          tool: 'benchmarkdotnet'
          output-file-path: BenchmarkDotNet.Artifacts/results/*.json
          alert-threshold: '150%'
          fail-on-alert: true
```

---

### 6.3 混沌测试

**改进方案**：

```csharp
[Fact]
public async Task Should_Reconnect_After_Network_Failure()
{
    // Arrange
    var consul = new TestConsulServer();
    var cfg = new CfgBuilder()
        .AddConsul(options => options.Address = consul.Address, level: 10)
        .Build();

    // Act - 模拟网络故障
    consul.SimulateNetworkFailure(TimeSpan.FromSeconds(5));

    // Assert - 应该自动重连
    await Task.Delay(TimeSpan.FromSeconds(10));
    Assert.True(cfg.IsConnected);
}
```

---

## 七、文档改进建议

### 7.1 添加迁移指南

```markdown
# 从 Microsoft.Extensions.Configuration 迁移

## 1. 替换 ConfigurationBuilder

```csharp
// 之前
var config = new ConfigurationBuilder()
    .AddJsonFile("appsettings.json")
    .AddEnvironmentVariables()
    .Build();

// 之后
var cfg = new CfgBuilder()
    .AddJson("config.json", level: 0)
    .AddEnvironmentVariables(level: 1, prefix: "APP_")
    .Build();
```

## 2. 替换配置读取

```csharp
// 之前
var value = config["Section:Key"];
var typedValue = config.GetValue<int>("Section:Key");

// 之后
var value = cfg["Section:Key"];
var typedValue = cfg.Get<int>("Section:Key");
```
```

---

### 7.2 添加最佳实践指南

```markdown
# Apq.Cfg 最佳实践

## 1. 配置层级设计

| 层级 | 用途 | 示例 |
|------|------|------|
| 0-2 | 基础配置 | config.json |
| 3-5 | 环境配置 | config.Production.json |
| 6-9 | 本地覆盖 | config.local.json |
| 10-19 | 远程配置 | Consul, Nacos |
| 20+ | 环境变量 | 最高优先级 |

## 2. 敏感配置处理

- 使用 Vault 存储密钥
- 启用配置脱敏
- 不要在日志中输出敏感值

## 3. 性能优化

- 使用 `GetMany()` 批量读取
- 启用配置缓存预热
- 避免在热路径中频繁读取配置
```

---

## 八、优先级总结

| 优先级 | 功能/改进 | 工作量 | 价值 |
|--------|----------|--------|------|
| **P0** | 配置验证框架 | 3-5 天 | 高 |
| **P0** | 配置快照导出 | 2-3 天 | 高 |
| **P1** | 日志集成 | 1-2 天 | 高 |
| **P1** | 配置差异对比 | 2-3 天 | 中 |
| **P1** | 配置模板 | 3-4 天 | 中 |
| **P1** | 配置继承 | 3-4 天 | 中 |
| **P2** | AWS Parameter Store | 5-7 天 | 中 |
| **P2** | Azure App Configuration | 5-7 天 | 中 |
| **P2** | 配置审计日志 | 2-3 天 | 中 |
| **P2** | 配置健康检查 | 1-2 天 | 低 |
| **P2** | 配置锁定 | 1 天 | 低 |
| **P3** | 字符串池化优化 | 1 天 | 低 |
| **P3** | Span<T> 优化 | 2 天 | 低 |
| **P3** | ValueTask 优化 | 1 天 | 低 |
| **P3** | 集成测试自动化 | 2-3 天 | 中 |

---

## 九、实施建议

### 第一阶段（1-2 周）
1. 实现配置验证框架
2. 实现配置快照导出
3. 添加日志集成

### 第二阶段（2-3 周）
1. 实现配置差异对比
2. 实现配置模板
3. 实现配置继承

### 第三阶段（3-4 周）
1. 添加 AWS Parameter Store 支持
2. 添加 Azure App Configuration 支持
3. 性能优化

### 第四阶段（持续）
1. 完善集成测试
2. 添加性能回归测试
3. 文档完善

---

*文档生成时间：2026-01-02*
